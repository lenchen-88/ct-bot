<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="description" content="Bootloader f&uuml;r den c't-Bot" />
<meta name="keywords" content="c't-Bot,Bootloader" />
<meta name="date" content="2007-01-17" />
<title>Bootloader f&uuml;r den c't-Bot</title>
</head>
<html>
<body>
	<h1>Bootloader f&uuml;r den c't-Bot</h1>
	
	<p>Wir haben den Bootloader von Martin Thomas (<a href="http://www.siwawi.arubi.uni-kl.de/avr_projects">http://www.siwawi.arubi.uni-kl.de/avr_projects</a>) mit in das c't-Bot-Projekt aufgenommen. Damit dauert das &Uuml;bertragen der Hex-Files gerade noch 14 Sekunden.</p>
	Sowohl f&uuml;r den ATmega32 als auch den ATmega644 ist der Bootloader bereits in den Code integriert. Man muss nur sicherstellen, dass 
	in der Datei ct-Bot.h der Schalter <code>BOOTLOADER_AVAILABLE</code> aktiviert ist und die Linkereinstellungen passen. 
	Es schadet &uuml;brigens nicht, den Bootloader immer mit zu &uuml;bersetzen.</p>

	<p>F&uuml;r den ATmega32 muss man dem Linker 
	<code>-Wl,--section-start=.bootloader=0x7C00</code> und f&uuml;r den ATmega644 
	<code>-Wl,--section-start=.bootloader=0xF800</code> mit auf den Weg geben. Am besten schneidet man sich die Parameter hier per cut'n'paste aus und fÃ¼gt sie in eclipse unter
	Project->Properties->C/C++-Build->Tool Settings->GCC Linker->Miscelaneous ein:</p>
	<img src="eclipse-linker.jpg">

	<p>Das entstandene Hex-File ct-Bot.hex muss man einmalig mit dem Programmierer der 
	Wahl in den Bot &uuml;bertragen &ndash; genauso wie vorher ohne Bootloader.
	Au&szlig;erdem muss man die Fuse-Bits nun anders setzen: 
	In Ponyprog muss nun ein bei BOOTRST und bei BOOTSZ0 ein H&auml;ckchen sein. 
	Bei BOOTSZ1 darf hingegen keines mehr sein.</p>
	<img src="ponyprog_atm32.jpg">
	
	<p>Wer statt PonyProg2000 lieber ein Kommandozeilen-Tool verwendet, um die Fuse-Bits zu setzen, findet in diesem Verzeichnis drei Hex-Dateien 
		(<a href="bootloader_hfuse.hex">bootloader_hfuse.hex</a>, <a href="bootloader_lfuse.hex">bootloader_lfuse.hex</a>, <a href="bootloader_lock.hex">bootloader_lock.hex</a>) die sich mit den Skripten im <a href="../flash_n_fuse">flash_n_fuse</a>-Verzeichnis &uuml;bertragen lassen.</p>
		

	<p>Ab jetzt wartet der Bot nach einem Reset 5 Sekunden auf eine eingehende Programmierverbindung.</p>
	
	<p>Nun kann man &uuml;ber eine RS-232- oder eine USB-2-Bot- oder eine LAN-/WLAN- (WiPort)-Verbindung den ATmega32 mit fast jedem beliebigen Programmierprogramm mit Daten bef&uuml;llen. Hier ein paar Beispiele:</p>
	
	<ul>
		<li><b>Netzwerk per WiPort:</b> ./avrdude -p m32 -c avr109 -P net:10.10.22.58:10002 -U flash:w:ct-Bot.hex:i -D -u</li>
		<li><b>USB-2-Bot auf COM3:</b> ./avrdude -p m32 -c avr109 -P com3 -U flash:w:ct-Bot.hex:i -D -u -b 57600</li>
		<li><b>USB-2-Bot unter Linux:</b> ./avrdude -p m32 -c avr109 -P /dev/ttyUSB0 -U flash:w:ct-Bot.hex:i -D -u -b 57600</li>
	</ul>
		
	<p><b>Tipps:</b> </p>
	<ul>
		<li>Wenn man den WiPort verwendet, muss man den Channel 2 
		(Serial Settings) auf 57600 Baud (8N1) stellen. Au&szlig;erdem sollte man sowohl
		 f&uuml;r den Input als auch den Output Buffer jeweils die beiden Optionen 
		"Flush .. With active connect"  und "Flush .. With passive connect" aktivieren.</li>
		<li>Achtung auch der WiPort braucht ein wenig Zeit zum Booten, es kannn also sein, dass er nicht gleich nach dem Power-on reagiert.</li>
		<li>Wenn man RS-232- oder USB-2-Bot-Verbindungen nutzt, sollte man unter Windows den COM-Port auf 57600 Baud (8N1) einstellen</li>
	</ul>
	<img src="wiport_serialsettings.jpg">
</body>
</html>