<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>c&#39;t-Bot: mmc.c Quellcode</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">c&#39;t-Bot
   &#160;<span id="projectnumber">1898</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Erzeugt von Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Hauptseite</span></a></li>
      <li><a href="pages.html"><span>Zus√§tzliche&#160;Informationen</span></a></li>
      <li><a href="annotated.html"><span>Datenstrukturen</span></a></li>
      <li class="current"><a href="files.html"><span>Dateien</span></a></li>
      <li><a href="dirs.html"><span>Verzeichnisse</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Auflistung&#160;der&#160;Dateien</span></a></li>
      <li><a href="globals.html"><span>Datei-Elemente</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_f02428e3da713fc394853d6cd2afbcd0.html">mcu</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">mmc.c</div>  </div>
</div>
<div class="contents">
<a href="mmc_8c.html">gehe zur Dokumentation dieser Datei</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * c&#39;t-Bot</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * This program is free software; you can redistribute it</span>
<a name="l00005"></a>00005 <span class="comment"> * and/or modify it under the terms of the GNU General</span>
<a name="l00006"></a>00006 <span class="comment"> * Public License as published by the Free Software</span>
<a name="l00007"></a>00007 <span class="comment"> * Foundation; either version 2 of the License, or (at your</span>
<a name="l00008"></a>00008 <span class="comment"> * option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment"> * This program is distributed in the hope that it will be</span>
<a name="l00010"></a>00010 <span class="comment"> * useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<a name="l00011"></a>00011 <span class="comment"> * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR</span>
<a name="l00012"></a>00012 <span class="comment"> * PURPOSE. See the GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> * You should have received a copy of the GNU General Public</span>
<a name="l00014"></a>00014 <span class="comment"> * License along with this program; if not, write to the Free</span>
<a name="l00015"></a>00015 <span class="comment"> * Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,</span>
<a name="l00016"></a>00016 <span class="comment"> * MA 02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> *</span>
<a name="l00018"></a>00018 <span class="comment"> */</span>
<a name="l00019"></a>00019 
<a name="l00030"></a>00030 <span class="comment">/* Die (zeitkritischen) Low-Level-Funktionen read_ und write_byte bzw. _sector liegen jetzt</span>
<a name="l00031"></a>00031 <span class="comment"> * in mmc-low.c. Der Assembler-Code ist a) wesentlich schneller und macht b) das Timing</span>
<a name="l00032"></a>00032 <span class="comment"> * unabhaengig vom verwendeten Compiler.</span>
<a name="l00033"></a>00033 <span class="comment"> * Die Portkonfiguration findet sich in mmc-low.h.</span>
<a name="l00034"></a>00034 <span class="comment"> *</span>
<a name="l00035"></a>00035 <span class="comment"> * Die MMC kann auf zwei Weisen angesprochen werden:</span>
<a name="l00036"></a>00036 <span class="comment"> * Entweder per Software-Steuerung (das ist die Standard-Einstellung), dafuer muss</span>
<a name="l00037"></a>00037 <span class="comment"> * SPI_AVAILABLE in ct-Bot.h AUS sein.</span>
<a name="l00038"></a>00038 <span class="comment"> * Oder per Hardware-SPI-Steuerung, dafuer ist ein kleiner Hardware-Umbau noetig, man</span>
<a name="l00039"></a>00039 <span class="comment"> * muss die Verbindung zwischen PC5 und dem Display trennen (busy-Leitung wird vom Display-</span>
<a name="l00040"></a>00040 <span class="comment"> * Treiber eh nicht genutzt) und auf PC5 den linken Radencoder legen. Ausserdem ist PB4</span>
<a name="l00041"></a>00041 <span class="comment"> * vom Radencoder zu trennen (der PB4-Pin kann fuer andere Zwecke genutzt werden, er muss</span>
<a name="l00042"></a>00042 <span class="comment"> * jedoch immer als OUTPUT konfiguriert sein). Schaltet man nun in ct-Bot.h SPI_AVAILABLE</span>
<a name="l00043"></a>00043 <span class="comment"> * AN, dann wird die Kommunikation mit der MMC per Hardware gesteuert - Vorteil ist eine</span>
<a name="l00044"></a>00044 <span class="comment"> * hoehere Transfer-Geschwindigkeit zur MMC (Faktor 2) und es sind ca. 430 Byte weniger im</span>
<a name="l00045"></a>00045 <span class="comment"> * Flash belegt.</span>
<a name="l00046"></a>00046 <span class="comment"> * Zu beachten ist, dass SPI_AVAILABLE von jetzt an immer eingeschaltet sein muss, auch</span>
<a name="l00047"></a>00047 <span class="comment"> * wenn man keine MMC-Unterstuetzung benoetigt, weil die Radencoder-Auswertung die</span>
<a name="l00048"></a>00048 <span class="comment"> * veraenderte Pin-Belegung immer beruecksichtigen muss.</span>
<a name="l00049"></a>00049 <span class="comment"> */</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#ifdef MCU</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="ct-Bot_8h.html" title="globale Schalter fuer die einzelnen Bot-Funktionalitaeten">ct-Bot.h</a>&quot;</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="preprocessor">#ifdef MMC_AVAILABLE</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="mmc_8h.html" title="Routinen zum Auslesen / Schreiben einer MMC-Karte.">mmc.h</a>&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;<a class="code" href="spi_8h.html" title="(Hardware-) SPI-Treiber">spi.h</a>&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;<a class="code" href="ena_8h.html" title="Routinen zur Steuerung der Enable-Leitungen.">ena.h</a>&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;<a class="code" href="timer_8h.html" title="Timer und Zaehler.">timer.h</a>&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;<a class="code" href="display_8h.html" title="Routinen zur Displaysteuerung.">display.h</a>&quot;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;<a class="code" href="led_8h.html" title="Routinen zur LED-Steuerung.">led.h</a>&quot;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;<a class="code" href="map_8h.html" title="Karte.">map.h</a>&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;<a class="code" href="mmc-low_8h.html" title="Low-Level-Routinen zum Lesen/Schreiben einer MMC / SD-Card.">mmc-low.h</a>&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;<a class="code" href="mmc-vm_8h.html" title="Virtual Memory Management mit MMC / SD-Card.">mmc-vm.h</a>&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;<a class="code" href="os__thread_8h.html" title="Threadmanagement fuer BotOS.">os_thread.h</a>&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;<a class="code" href="log_8h.html" title="Routinen zum Loggen von Informationen.">log.h</a>&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00068"></a>00068 
<a name="l00069"></a><a class="code" href="mmc_8c.html#affe9a50ec46df6b49325669ec060789e">00069</a> uint8_t <a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> = 1; 
<a name="l00071"></a>00071 <span class="preprocessor">#ifndef SPI_AVAILABLE</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span>
<a name="l00076"></a>00076 <span class="keywordtype">void</span> <a class="code" href="mmc_8c.html#a33b293aa95d995d8903d5a687cb5e2a7">mmc_write_byte</a>(uint8_t data);
<a name="l00077"></a>00077 
<a name="l00082"></a>00082 uint8_t <a class="code" href="mmc_8c.html#a4f77044232e9cffe7e4c1fa8d24dcd22">mmc_read_byte</a>(<span class="keywordtype">void</span>);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="keyword">static</span> uint8_t mmc_write_command(uint8_t * cmd);
<a name="l00085"></a>00085 
<a name="l00092"></a>00092 <span class="keyword">static</span> uint8_t <a class="code" href="mmc_8h.html#a032097eb5e379d13ad27671730c01a80">mmc_read_block</a>(uint8_t * cmd, <span class="keywordtype">void</span> * buffer, uint16_t count) {
<a name="l00093"></a>00093     <a class="code" href="os__thread_8h.html#a29e5f7c4cb7a64b0d9157f2a9efdcdc5" title="Schuetzt den folgenden Block (bis os_exitCS()) vor Threadswitches.">os_enterCS</a>();
<a name="l00094"></a>00094     <span class="comment">/* Kommando cmd an MMC/SD-Karte senden */</span>
<a name="l00095"></a>00095     <span class="keywordflow">if</span> (mmc_write_command(cmd) != 0) {
<a name="l00096"></a>00096         <a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> = 1;
<a name="l00097"></a>00097         <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00098"></a>00098         <span class="keywordflow">return</span> 1;
<a name="l00099"></a>00099     }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>    <a class="code" href="led_8h.html#a447c990bb9e81e6e533f0ba69f97b1e9">LED_on</a>(<a class="code" href="led_8h.html#a821031f9c11c8a45d7b9ada7c0979d74">LED_GRUEN</a>);
<a name="l00103"></a>00103 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span>    <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00105"></a>00105     <span class="comment">/* Warten auf Start Byte von der MMC/SD-Karte (FEh/Start Byte) */</span>
<a name="l00106"></a>00106     uint8_t timeout = 0;
<a name="l00107"></a>00107     uint8_t result = 0;
<a name="l00108"></a>00108     <span class="keywordflow">while</span> (result != 0xfe) {
<a name="l00109"></a>00109         <a class="code" href="os__thread_8h.html#a29e5f7c4cb7a64b0d9157f2a9efdcdc5" title="Schuetzt den folgenden Block (bis os_exitCS()) vor Threadswitches.">os_enterCS</a>();
<a name="l00110"></a>00110         result = <a class="code" href="mmc_8c.html#a4f77044232e9cffe7e4c1fa8d24dcd22">mmc_read_byte</a>();
<a name="l00111"></a>00111         <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00112"></a>00112         <span class="keywordflow">if</span> (--timeout == 0) <span class="keywordflow">break</span>;
<a name="l00113"></a>00113     }
<a name="l00114"></a>00114 
<a name="l00115"></a>00115     <a class="code" href="os__thread_8h.html#a29e5f7c4cb7a64b0d9157f2a9efdcdc5" title="Schuetzt den folgenden Block (bis os_exitCS()) vor Threadswitches.">os_enterCS</a>();
<a name="l00116"></a>00116     uint16_t <a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>;
<a name="l00117"></a>00117     uint8_t * ptr = buffer;
<a name="l00118"></a>00118     <span class="comment">/* Lesen des Blocks (max 512 Bytes) von MMC/SD-Karte */</span>
<a name="l00119"></a>00119     <span class="keywordflow">for</span> (i = 0; i &lt; count; ++<a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>) {
<a name="l00120"></a>00120         *ptr++ = <a class="code" href="mmc_8c.html#a4f77044232e9cffe7e4c1fa8d24dcd22">mmc_read_byte</a>();
<a name="l00121"></a>00121     }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="comment">/* CRC-Byte auslesen */</span>
<a name="l00124"></a>00124     <a class="code" href="mmc_8c.html#a4f77044232e9cffe7e4c1fa8d24dcd22">mmc_read_byte</a>(); <span class="comment">// CRC - Byte wird nicht ausgewertet</span>
<a name="l00125"></a>00125     <a class="code" href="mmc_8c.html#a4f77044232e9cffe7e4c1fa8d24dcd22">mmc_read_byte</a>(); <span class="comment">// CRC - Byte wird nicht ausgewertet</span>
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     <span class="comment">/* MMC/SD-Karte inaktiv schalten */</span>
<a name="l00128"></a>00128     <a class="code" href="ena_8h.html#ac992908542eebed9776522f8eafc0ff9">ENA_off</a>(<a class="code" href="ena_8h.html#a3ad1a6346c07216d560ebb698453d399">ENA_MMC</a>);
<a name="l00129"></a>00129 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span>    <a class="code" href="led_8h.html#abd7b28be86683943e4f3cea44ec0de76">LED_off</a>(<a class="code" href="led_8h.html#a821031f9c11c8a45d7b9ada7c0979d74">LED_GRUEN</a>);
<a name="l00131"></a>00131 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>    <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00133"></a>00133     <span class="keywordflow">if</span> (timeout == 0) {
<a name="l00134"></a>00134         <a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> = 1;
<a name="l00135"></a>00135         <span class="keywordflow">return</span> 1; <span class="comment">// Abbruch durch Timeout</span>
<a name="l00136"></a>00136     }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="keywordflow">return</span> 0; <span class="comment">// alles ok</span>
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 <span class="preprocessor">#else // SPI_AVAILABLE</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span>
<a name="l00142"></a><a class="code" href="mmc_8c.html#a4f77044232e9cffe7e4c1fa8d24dcd22">00142</a> <span class="preprocessor">#define mmc_read_byte   SPI_MasterReceive </span>
<a name="l00143"></a><a class="code" href="mmc_8c.html#a33b293aa95d995d8903d5a687cb5e2a7">00143</a> <span class="preprocessor">#define mmc_write_byte  SPI_MasterTransmit </span>
<a name="l00150"></a>00150 <span class="preprocessor">static uint32_t wait_for_byte(uint8_t data) {</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span>    uint32_t timeout = 0x1ffff;
<a name="l00152"></a>00152     <span class="comment">/* warten, bis Karte mit &quot;data&quot; antwortet */</span>
<a name="l00153"></a>00153     uint8_t response = 0;
<a name="l00154"></a>00154     <span class="keywordflow">do</span> {
<a name="l00155"></a>00155         SPDR = 0xff;
<a name="l00156"></a>00156         <span class="keywordflow">if</span> (--timeout == 0) <span class="keywordflow">break</span>;
<a name="l00157"></a>00157         <span class="keywordflow">while</span>(!(SPSR &amp; (1 &lt;&lt; SPIF))) {}
<a name="l00158"></a>00158         response = SPDR;
<a name="l00159"></a>00159     } <span class="keywordflow">while</span> (response != data);
<a name="l00160"></a>00160     <span class="keywordflow">return</span> timeout;
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00169"></a>00169 <span class="keyword">static</span> uint8_t prepare_transfer_spi(uint8_t cmd, uint32_t addr) {
<a name="l00170"></a>00170     <span class="comment">/* Init-Check */</span>
<a name="l00171"></a>00171     uint8_t result = <a class="code" href="mmc_8h.html#aa4589b4a3e427f3b807234a46b682fcb" title="Schaltet die Karte aktiv und checkt dabei die Initialisierung.">mmc_enable</a>();
<a name="l00172"></a>00172     <span class="keywordflow">if</span> (result != 0) {
<a name="l00173"></a>00173         <span class="keywordflow">return</span> result;
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176     <span class="comment">/* (addr &lt;&lt;= 1) &amp; 0x00ff ffff */</span>
<a name="l00177"></a>00177     __asm__ __volatile__(
<a name="l00178"></a>00178         <span class="stringliteral">&quot;lsl %A0        \n\t&quot;</span>
<a name="l00179"></a>00179         <span class="stringliteral">&quot;rol %B0        \n\t&quot;</span>
<a name="l00180"></a>00180         <span class="stringliteral">&quot;rol %C0            &quot;</span>
<a name="l00181"></a>00181         :   <span class="stringliteral">&quot;=r&quot;</span>    (addr)
<a name="l00182"></a>00182         :   <span class="stringliteral">&quot;0&quot;</span>     (addr)
<a name="l00183"></a>00183     );
<a name="l00184"></a>00184 
<a name="l00185"></a>00185     <span class="comment">/* Kommando senden */</span>
<a name="l00186"></a>00186     <a class="code" href="spi_8h.html#aa1f680328ddb86c80716bf035e6652dd" title="Uebertraegt ein Byte per SPI vom Master zum Slave.">SPI_MasterTransmit</a>(cmd); <span class="comment">// 0x51: lesen, 0x schreiben</span>
<a name="l00187"></a>00187     <span class="keyword">typedef</span> <span class="keyword">union </span>{
<a name="l00188"></a>00188         uint32_t u32;
<a name="l00189"></a>00189         uint8_t u8[4];
<a name="l00190"></a>00190     } mmc_addr_t;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192     mmc_addr_t tmp;
<a name="l00193"></a>00193     tmp.u32 = addr;
<a name="l00194"></a>00194     <a class="code" href="spi_8h.html#aa1f680328ddb86c80716bf035e6652dd" title="Uebertraegt ein Byte per SPI vom Master zum Slave.">SPI_MasterTransmit</a>(tmp.u8[2]); <span class="comment">// Byteadresse des Blocks (&quot;big-endian&quot;)</span>
<a name="l00195"></a>00195     <a class="code" href="spi_8h.html#aa1f680328ddb86c80716bf035e6652dd" title="Uebertraegt ein Byte per SPI vom Master zum Slave.">SPI_MasterTransmit</a>(tmp.u8[1]);
<a name="l00196"></a>00196     <a class="code" href="spi_8h.html#aa1f680328ddb86c80716bf035e6652dd" title="Uebertraegt ein Byte per SPI vom Master zum Slave.">SPI_MasterTransmit</a>(tmp.u8[0]);
<a name="l00197"></a>00197     <a class="code" href="spi_8h.html#aa1f680328ddb86c80716bf035e6652dd" title="Uebertraegt ein Byte per SPI vom Master zum Slave.">SPI_MasterTransmit</a>(0x00);
<a name="l00198"></a>00198     <a class="code" href="spi_8h.html#aa1f680328ddb86c80716bf035e6652dd" title="Uebertraegt ein Byte per SPI vom Master zum Slave.">SPI_MasterTransmit</a>(0xff); <span class="comment">// CRC</span>
<a name="l00199"></a>00199     <span class="keywordflow">return</span> 0;
<a name="l00200"></a>00200 }
<a name="l00201"></a>00201 
<a name="l00209"></a><a class="code" href="mmc_8c.html#a48e9899af9e06dd1091575c2654c9afc">00209</a> uint8_t <a class="code" href="mmc_8h.html#a48e9899af9e06dd1091575c2654c9afc" title="Liest einen Block von der Karte.">mmc_read_sector_spi</a>(uint8_t cmd, uint32_t addr, <span class="keywordtype">void</span> * buffer) {
<a name="l00210"></a>00210     <a class="code" href="os__thread_8h.html#a29e5f7c4cb7a64b0d9157f2a9efdcdc5" title="Schuetzt den folgenden Block (bis os_exitCS()) vor Threadswitches.">os_enterCS</a>();
<a name="l00211"></a>00211     <span class="comment">/* cmd[] = {0x51,addr,addr,addr,0x00,0xFF} */</span>
<a name="l00212"></a>00212     <span class="keywordflow">if</span> (prepare_transfer_spi(cmd, addr) != 0) {
<a name="l00213"></a>00213         <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00214"></a>00214         <span class="keywordflow">return</span> 1;
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span>    <a class="code" href="led_8h.html#a447c990bb9e81e6e533f0ba69f97b1e9">LED_on</a>(<a class="code" href="led_8h.html#a821031f9c11c8a45d7b9ada7c0979d74">LED_GRUEN</a>);
<a name="l00219"></a>00219 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span>
<a name="l00221"></a>00221     <span class="comment">/* Warten auf Start-Byte von der MMC/SD-Karte (0xfe == Start-Byte) */</span>
<a name="l00222"></a>00222     <span class="keywordflow">if</span> (wait_for_byte(0xfe) == 0) {
<a name="l00223"></a>00223         <a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> = 1;
<a name="l00224"></a>00224 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span>        <a class="code" href="led_8h.html#abd7b28be86683943e4f3cea44ec0de76">LED_off</a>(<a class="code" href="led_8h.html#a821031f9c11c8a45d7b9ada7c0979d74">LED_GRUEN</a>);
<a name="l00226"></a>00226 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span>        <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00228"></a>00228         <span class="keywordflow">return</span> 3; <span class="comment">// Abbruch durch Timeout</span>
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     <span class="comment">/* Lesen des Blocks (512 Bytes) von MMC/SD-Karte */</span>
<a name="l00232"></a>00232 <span class="preprocessor">#ifdef MMC_AGGRESSIVE_OPTIMIZATION</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span>    SPDR = 0;   <span class="comment">// start 1st SPI-transfer</span>
<a name="l00234"></a>00234     int16_t i = cmd != 0x51 ? 15 : 511; <span class="comment">// num of bytes to read</span>
<a name="l00235"></a>00235     uint8_t tmp;
<a name="l00236"></a>00236     __asm__ __volatile__(
<a name="l00237"></a>00237         <span class="stringliteral">&quot;%=:                        \n\t&quot;</span>
<a name="l00238"></a>00238         <span class="stringliteral">&quot;adiw %2,1      ; 2 nop     \n\t&quot;</span> <span class="comment">// wait 16 cycles for reception complete</span>
<a name="l00239"></a>00239         <span class="stringliteral">&quot;sbiw %2,1      ; 2 nop     \n\t&quot;</span>
<a name="l00240"></a>00240         <span class="stringliteral">&quot;adiw %2,1      ; 2 nop     \n\t&quot;</span>
<a name="l00241"></a>00241         <span class="stringliteral">&quot;sbiw %2,1      ; 2 nop     \n\t&quot;</span>
<a name="l00242"></a>00242         <span class="stringliteral">&quot;nop            ; 1 nop     \n\t&quot;</span>
<a name="l00243"></a>00243         <span class="stringliteral">&quot;in %0,%3       ; tmp       \n\t&quot;</span> <span class="comment">// load from SPDR</span>
<a name="l00244"></a>00244         <span class="stringliteral">&quot;out %3,__zero_reg__        \n\t&quot;</span> <span class="comment">// start next SPI-transfer</span>
<a name="l00245"></a>00245         <span class="stringliteral">&quot;st Z+,%0       ; tmp       \n\t&quot;</span> <span class="comment">// save to *buffer</span>
<a name="l00246"></a>00246         <span class="stringliteral">&quot;sbiw %A1,1     ; i         \n\t&quot;</span> <span class="comment">// i--</span>
<a name="l00247"></a>00247         <span class="stringliteral">&quot;sbrs %B1,7     ; i         \n\t&quot;</span> <span class="comment">// i == 0?</span>
<a name="l00248"></a>00248         <span class="stringliteral">&quot;rjmp %=b                       &quot;</span>
<a name="l00249"></a>00249         : <span class="stringliteral">&quot;=&amp;r&quot;</span> (tmp)
<a name="l00250"></a>00250         : <span class="stringliteral">&quot;w&quot;</span> (i), <span class="stringliteral">&quot;z&quot;</span> (buffer), <span class="stringliteral">&quot;M&quot;</span> (_SFR_IO_ADDR(SPDR))
<a name="l00251"></a>00251         : <span class="stringliteral">&quot;memory&quot;</span>
<a name="l00252"></a>00252     );
<a name="l00253"></a>00253 <span class="preprocessor">#else</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span>    uint8_t <a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>,<a class="code" href="behaviour__drive__chess_8c.html#aac1217779551b743f5645c17740178e3">j</a>,<a class="code" href="behaviour__drive__chess_8c.html#a43ed7e3846304dce8b14d9bc81f63fef">k</a>;
<a name="l00255"></a>00255     <span class="keywordflow">if</span> (cmd != 0x51) {
<a name="l00256"></a>00256         k = 248;
<a name="l00257"></a>00257     } <span class="keywordflow">else</span> {
<a name="l00258"></a>00258         k = 0;
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260     SPDR = 0;   <span class="comment">// start SPI-transfer</span>
<a name="l00261"></a>00261     uint8_t * ptr = buffer;
<a name="l00262"></a>00262     <span class="keywordflow">for</span> (i=2; i&gt;0; i--) {
<a name="l00263"></a>00263         j = <a class="code" href="behaviour__drive__chess_8c.html#a43ed7e3846304dce8b14d9bc81f63fef">k</a>;
<a name="l00264"></a>00264         uint8_t tmp;
<a name="l00265"></a>00265         <span class="keywordflow">do</span> {
<a name="l00266"></a>00266             <span class="keywordflow">while</span>(!(SPSR &amp; (1&lt;&lt;SPIF))) {} <span class="comment">// wait for reception complete</span>
<a name="l00267"></a>00267             tmp = SPDR; <span class="comment">// load from SPDR</span>
<a name="l00268"></a>00268             SPDR = 0; <span class="comment">// start next SPI-transfer</span>
<a name="l00269"></a>00269             *ptr = tmp; <span class="comment">// save to *buffer</span>
<a name="l00270"></a>00270             ptr++;
<a name="l00271"></a>00271         } <span class="keywordflow">while</span> (++j != 0);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 <span class="preprocessor">#endif // MMC_AGGRESSIVE_OPTIMIZATION</span>
<a name="l00274"></a>00274 <span class="preprocessor"></span>
<a name="l00275"></a>00275     <span class="comment">/* CRC-Bytes auslesen */</span>
<a name="l00276"></a>00276     <a class="code" href="spi_8h.html#a74d326dbf4a55103a6e288bfa7ada970" title="Uebertraegt ein Byte per SPI vom Slave zum Master.">SPI_MasterReceive</a>(); <span class="comment">// CRC-Byte wird nicht ausgewertet</span>
<a name="l00277"></a>00277     <a class="code" href="spi_8h.html#a74d326dbf4a55103a6e288bfa7ada970" title="Uebertraegt ein Byte per SPI vom Slave zum Master.">SPI_MasterReceive</a>(); <span class="comment">// CRC-Byte wird nicht ausgewertet</span>
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span>    <a class="code" href="led_8h.html#abd7b28be86683943e4f3cea44ec0de76">LED_off</a>(<a class="code" href="led_8h.html#a821031f9c11c8a45d7b9ada7c0979d74">LED_GRUEN</a>);
<a name="l00281"></a>00281 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00282"></a>00282 <span class="preprocessor"></span>    <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00283"></a>00283     <span class="keywordflow">return</span> 0;
<a name="l00284"></a>00284 }
<a name="l00285"></a>00285 
<a name="l00292"></a><a class="code" href="mmc_8c.html#a4cc054aa8ca060c526f00bf179d9db38">00292</a> uint8_t <a class="code" href="mmc_8h.html#a4cc054aa8ca060c526f00bf179d9db38" title="Schreibt einen 512-Byte Sektor auf die Karte.">mmc_write_sector_spi</a>(uint32_t addr, <span class="keywordtype">void</span> * buffer) {
<a name="l00293"></a>00293     <a class="code" href="os__thread_8h.html#a29e5f7c4cb7a64b0d9157f2a9efdcdc5" title="Schuetzt den folgenden Block (bis os_exitCS()) vor Threadswitches.">os_enterCS</a>();
<a name="l00294"></a>00294     <span class="comment">/* cmd[] = {0x58,addr,addr,addr,0x00,0xFF} */</span>
<a name="l00295"></a>00295     <span class="keywordflow">if</span> (prepare_transfer_spi(0x58, addr) != 0) {
<a name="l00296"></a>00296         <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00297"></a>00297         <span class="keywordflow">return</span> 1;
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00301"></a>00301 <span class="preprocessor"></span>    <a class="code" href="led_8h.html#a447c990bb9e81e6e533f0ba69f97b1e9">LED_on</a>(<a class="code" href="led_8h.html#a2eddf48fa63431bcbfcab672956ac233">LED_ROT</a>);
<a name="l00302"></a>00302 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span>
<a name="l00304"></a>00304     <span class="comment">/* Startbyte an MMC/SD-Karte senden */</span>
<a name="l00305"></a>00305     <a class="code" href="spi_8h.html#aa1f680328ddb86c80716bf035e6652dd" title="Uebertraegt ein Byte per SPI vom Master zum Slave.">SPI_MasterTransmit</a>(0xfe);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307     <span class="comment">/* Schreiben des Blocks (512 Bytes) auf MMC/SD-Karte */</span>
<a name="l00308"></a>00308 <span class="preprocessor">#ifdef MMC_AGGRESSIVE_OPTIMIZATION</span>
<a name="l00309"></a>00309 <span class="preprocessor"></span>    int16_t i = 511;
<a name="l00310"></a>00310     uint8_t tmp;
<a name="l00311"></a>00311     __asm__ __volatile__(
<a name="l00312"></a>00312         <span class="stringliteral">&quot;%=:                        \n\t&quot;</span>
<a name="l00313"></a>00313         <span class="stringliteral">&quot;ld %0,Y        ; tmp       \n\t&quot;</span> <span class="comment">// load from *buffer</span>
<a name="l00314"></a>00314         <span class="stringliteral">&quot;out %3,%0                  \n\t&quot;</span> <span class="comment">// start next SPI-transfer</span>
<a name="l00315"></a>00315         <span class="stringliteral">&quot;adiw %2,1      ; 2 nop     \n\t&quot;</span> <span class="comment">// wait 16 cycles for reception complete</span>
<a name="l00316"></a>00316         <span class="stringliteral">&quot;sbiw %2,1      ; 2 nop     \n\t&quot;</span>
<a name="l00317"></a>00317         <span class="stringliteral">&quot;adiw %2,1      ; 2 nop     \n\t&quot;</span>
<a name="l00318"></a>00318         <span class="stringliteral">&quot;sbiw %2,1      ; 2 nop     \n\t&quot;</span>
<a name="l00319"></a>00319         <span class="stringliteral">&quot;adiw %2,1      ; buffer++  \n\t&quot;</span>
<a name="l00320"></a>00320         <span class="stringliteral">&quot;sbiw %A1,1     ; i         \n\t&quot;</span>
<a name="l00321"></a>00321         <span class="stringliteral">&quot;sbrs %B1,7     ; i         \n\t&quot;</span>
<a name="l00322"></a>00322         <span class="stringliteral">&quot;rjmp %=b                       &quot;</span>
<a name="l00323"></a>00323         : <span class="stringliteral">&quot;=&amp;r&quot;</span> (tmp)
<a name="l00324"></a>00324         : <span class="stringliteral">&quot;w&quot;</span> (i), <span class="stringliteral">&quot;y&quot;</span> (buffer), <span class="stringliteral">&quot;M&quot;</span> (_SFR_IO_ADDR(SPDR))
<a name="l00325"></a>00325         : <span class="stringliteral">&quot;memory&quot;</span>
<a name="l00326"></a>00326     );
<a name="l00327"></a>00327     <span class="comment">/* Wait for SPI ready */</span>
<a name="l00328"></a>00328     <span class="keywordflow">while</span> (!(SPSR &amp; (1 &lt;&lt; SPIF))) {}
<a name="l00329"></a>00329 <span class="preprocessor">#else</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span>    uint8_t <a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>,<a class="code" href="behaviour__drive__chess_8c.html#aac1217779551b743f5645c17740178e3">j</a>, tmp;
<a name="l00331"></a>00331     uint8_t * ptr = buffer;
<a name="l00332"></a>00332     tmp = *ptr; <span class="comment">// load from *buffer</span>
<a name="l00333"></a>00333     ptr++;
<a name="l00334"></a>00334     <span class="keywordflow">for</span> (i=2; i&gt;0; i--) {
<a name="l00335"></a>00335         j = 0;
<a name="l00336"></a>00336         <span class="keywordflow">do</span> {
<a name="l00337"></a>00337             SPDR = tmp; <span class="comment">// save to SPDR</span>
<a name="l00338"></a>00338             tmp = *ptr; <span class="comment">// load from *buffer</span>
<a name="l00339"></a>00339             ptr++;
<a name="l00340"></a>00340             j++;
<a name="l00341"></a>00341             <span class="keywordflow">if</span> (j == 0) {
<a name="l00342"></a>00342                 <span class="keywordflow">while</span>(!(SPSR &amp; (1&lt;&lt;SPIF))) {}
<a name="l00343"></a>00343                 <span class="keywordflow">break</span>; <span class="comment">// exit inner loop</span>
<a name="l00344"></a>00344             }
<a name="l00345"></a>00345             <span class="keywordflow">while</span>(!(SPSR &amp; (1&lt;&lt;SPIF))) {} <span class="comment">// wait for transmission to complete</span>
<a name="l00346"></a>00346         } <span class="keywordflow">while</span> (1);
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348 <span class="preprocessor">#endif // MMC_AGGRESSIVE_OPTIMIZATION</span>
<a name="l00349"></a>00349 <span class="preprocessor"></span>
<a name="l00350"></a>00350     <span class="comment">/* CRC-Dummy schreiben */</span>
<a name="l00351"></a>00351     <a class="code" href="spi_8h.html#aa1f680328ddb86c80716bf035e6652dd" title="Uebertraegt ein Byte per SPI vom Master zum Slave.">SPI_MasterTransmit</a>(0xff);
<a name="l00352"></a>00352     <a class="code" href="spi_8h.html#aa1f680328ddb86c80716bf035e6652dd" title="Uebertraegt ein Byte per SPI vom Master zum Slave.">SPI_MasterTransmit</a>(0xff);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <span class="comment">/* warten, bis Karte nicht mehr busy */</span>
<a name="l00355"></a>00355     <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00356"></a>00356     uint8_t timeout_high = 0;
<a name="l00357"></a>00357 <span class="preprocessor">#ifdef MMC_AGGRESSIVE_OPTIMIZATION</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span>    uint16_t timeout;
<a name="l00359"></a>00359     SPDR = 0xff;
<a name="l00360"></a>00360     __asm__ __volatile__(
<a name="l00361"></a>00361         <span class="stringliteral">&quot;ldi %A0,255        ; timeout   \n\t&quot;</span>
<a name="l00362"></a>00362         <span class="stringliteral">&quot;ldi %B0,1          ; =         \n\t&quot;</span>
<a name="l00363"></a>00363         <span class="stringliteral">&quot;mov %1,%B0         ; 0x01ffff  \n\t&quot;</span>
<a name="l00364"></a>00364         <span class="stringliteral">&quot;ldi %B0,255                    \n\t&quot;</span>
<a name="l00365"></a>00365         <span class="stringliteral">&quot;1:                             \n\t&quot;</span>
<a name="l00366"></a>00366         <span class="stringliteral">&quot;subi %A0,1         ; timeout-- \n\t&quot;</span>
<a name="l00367"></a>00367         <span class="stringliteral">&quot;sbci %B0,0                     \n\t&quot;</span>
<a name="l00368"></a>00368         <span class="stringliteral">&quot;sbc %1,__zero_reg__            \n\t&quot;</span>
<a name="l00369"></a>00369         <span class="stringliteral">&quot;breq 2f                        \n\t&quot;</span>
<a name="l00370"></a>00370         <span class="stringliteral">&quot;adiw r28,1         ; 2 nop     \n\t&quot;</span>
<a name="l00371"></a>00371         <span class="stringliteral">&quot;sbiw r28,1         ; 2 nop     \n\t&quot;</span>
<a name="l00372"></a>00372         <span class="stringliteral">&quot;adiw r28,1         ; 2 nop     \n\t&quot;</span>
<a name="l00373"></a>00373         <span class="stringliteral">&quot;sbiw r28,1         ; 2 nop     \n\t&quot;</span>
<a name="l00374"></a>00374         <span class="stringliteral">&quot;ldi r25,lo8(-1)    ; 1 nop     \n\t&quot;</span>
<a name="l00375"></a>00375         <span class="stringliteral">&quot;in r24,%2          ;           \n\t&quot;</span>
<a name="l00376"></a>00376         <span class="stringliteral">&quot;out %2,r25         ;           \n\t&quot;</span>
<a name="l00377"></a>00377         <span class="stringliteral">&quot;cpi r24,lo8(-1)    ; == 0xff?  \n\t&quot;</span>
<a name="l00378"></a>00378         <span class="stringliteral">&quot;brne 1b                        \n\t&quot;</span>
<a name="l00379"></a>00379         <span class="stringliteral">&quot;2:                                 &quot;</span>
<a name="l00380"></a>00380         : <span class="stringliteral">&quot;=&amp;d&quot;</span> (timeout), <span class="stringliteral">&quot;=&amp;r&quot;</span> (timeout_high)
<a name="l00381"></a>00381         : <span class="stringliteral">&quot;M&quot;</span> (_SFR_IO_ADDR(SPDR))
<a name="l00382"></a>00382         : <span class="stringliteral">&quot;r24&quot;</span>, <span class="stringliteral">&quot;r25&quot;</span>
<a name="l00383"></a>00383     );
<a name="l00384"></a>00384 <span class="preprocessor">#else</span>
<a name="l00385"></a>00385 <span class="preprocessor"></span>    uint32_t timeout = wait_for_byte(0xff);
<a name="l00386"></a>00386 <span class="preprocessor">#endif // MMC_AMMC_AGGRESSIVE_OPTIMIZATION</span>
<a name="l00387"></a>00387 <span class="preprocessor"></span>
<a name="l00388"></a>00388     <a class="code" href="os__thread_8h.html#a29e5f7c4cb7a64b0d9157f2a9efdcdc5" title="Schuetzt den folgenden Block (bis os_exitCS()) vor Threadswitches.">os_enterCS</a>();
<a name="l00389"></a>00389 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00390"></a>00390 <span class="preprocessor"></span>    <a class="code" href="led_8h.html#abd7b28be86683943e4f3cea44ec0de76">LED_off</a>(<a class="code" href="led_8h.html#a2eddf48fa63431bcbfcab672956ac233">LED_ROT</a>);
<a name="l00391"></a>00391 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00392"></a>00392 <span class="preprocessor"></span>    <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00393"></a>00393 
<a name="l00394"></a>00394     <span class="keywordflow">if</span> (timeout == 0 &amp;&amp; timeout_high == 0) {
<a name="l00395"></a>00395         <a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> = 1;
<a name="l00396"></a>00396         <span class="keywordflow">return</span> 3;
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398     <span class="keywordflow">return</span> 0;
<a name="l00399"></a>00399 }
<a name="l00400"></a>00400 <span class="preprocessor">#endif // SPI_AVAILABLE</span>
<a name="l00401"></a>00401 <span class="preprocessor"></span>
<a name="l00406"></a><a class="code" href="mmc_8c.html#aa4589b4a3e427f3b807234a46b682fcb">00406</a> uint8_t <a class="code" href="mmc_8h.html#aa4589b4a3e427f3b807234a46b682fcb" title="Schaltet die Karte aktiv und checkt dabei die Initialisierung.">mmc_enable</a>(<span class="keywordtype">void</span>) {
<a name="l00407"></a>00407     <span class="keywordflow">if</span> (<a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> != 0) {
<a name="l00408"></a>00408         <a class="code" href="mmc_8h.html#ae5fdd633809bced672d377c8504af7b6" title="Initialisiere die MMC/SD-Karte.">mmc_init</a>();
<a name="l00409"></a>00409         <span class="keywordflow">if</span> (<a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> != 0) {
<a name="l00410"></a>00410             <span class="keywordflow">return</span> <a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a>;
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412     }
<a name="l00413"></a>00413     <a class="code" href="ena_8h.html#a51c24b2a246e1b3cbd3df73a7ac662ad">ENA_on</a>(<a class="code" href="ena_8h.html#a3ad1a6346c07216d560ebb698453d399">ENA_MMC</a>);
<a name="l00414"></a>00414     <a class="code" href="ena_8h.html#ac992908542eebed9776522f8eafc0ff9">ENA_off</a>(<a class="code" href="ena_8h.html#a3ad1a6346c07216d560ebb698453d399">ENA_MMC</a>);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     <a class="code" href="mmc_8c.html#a33b293aa95d995d8903d5a687cb5e2a7">mmc_write_byte</a>(0xff);
<a name="l00417"></a>00417 
<a name="l00418"></a>00418     <a class="code" href="ena_8h.html#a51c24b2a246e1b3cbd3df73a7ac662ad">ENA_on</a>(<a class="code" href="ena_8h.html#a3ad1a6346c07216d560ebb698453d399">ENA_MMC</a>);
<a name="l00419"></a>00419 
<a name="l00420"></a>00420     <span class="keywordflow">return</span> 0;
<a name="l00421"></a>00421 }
<a name="l00422"></a>00422 
<a name="l00428"></a>00428 <span class="keyword">static</span> uint8_t mmc_write_command(uint8_t * cmd) {
<a name="l00429"></a>00429     uint8_t result = 0xff;
<a name="l00430"></a>00430     uint16_t timeout = 0;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432     <span class="keywordflow">if</span> (<a class="code" href="mmc_8h.html#aa4589b4a3e427f3b807234a46b682fcb" title="Schaltet die Karte aktiv und checkt dabei die Initialisierung.">mmc_enable</a>() != 0) {
<a name="l00433"></a>00433         <span class="keywordflow">return</span> 0xff; <span class="comment">// MMC / SD-Card aktiv schalten</span>
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436     <span class="comment">// sendet 6 Byte Kommando</span>
<a name="l00437"></a>00437     int8_t <a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>;
<a name="l00438"></a>00438     <span class="keywordflow">for</span> (i = 5; i &gt;= 0; --<a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>) {
<a name="l00439"></a>00439         <span class="comment">// sendet 6 Byte Kommando zur MMC/SD-Karte</span>
<a name="l00440"></a>00440         <a class="code" href="mmc_8c.html#a33b293aa95d995d8903d5a687cb5e2a7">mmc_write_byte</a>(*cmd++);
<a name="l00441"></a>00441     }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443     <span class="comment">// Wartet auf eine gueltige Antwort von der MMC/SD-Karte</span>
<a name="l00444"></a>00444     <span class="keywordflow">while</span> (result == 0xff) {
<a name="l00445"></a>00445         result = <a class="code" href="mmc_8c.html#a4f77044232e9cffe7e4c1fa8d24dcd22">mmc_read_byte</a>();
<a name="l00446"></a>00446         <span class="keywordflow">if</span> (timeout++ &gt; <a class="code" href="mmc-low_8h.html#abecee47f83881b14725d09934ca8e49e">MMC_TIMEOUT</a>) {
<a name="l00447"></a>00447             <span class="keywordflow">break</span>; <span class="comment">// Abbruch da die MMC/SD-Karte nicht antwortet</span>
<a name="l00448"></a>00448         }
<a name="l00449"></a>00449     }
<a name="l00450"></a>00450 
<a name="l00451"></a>00451     <span class="keywordflow">return</span> result;
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 
<a name="l00458"></a><a class="code" href="mmc_8c.html#ae5fdd633809bced672d377c8504af7b6">00458</a> uint8_t <a class="code" href="mmc_8h.html#ae5fdd633809bced672d377c8504af7b6" title="Initialisiere die MMC/SD-Karte.">mmc_init</a>(<span class="keywordtype">void</span>) {
<a name="l00459"></a>00459     <a class="code" href="os__thread_8h.html#a29e5f7c4cb7a64b0d9157f2a9efdcdc5" title="Schuetzt den folgenden Block (bis os_exitCS()) vor Threadswitches.">os_enterCS</a>();
<a name="l00460"></a>00460     <a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> = 0;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 <span class="preprocessor">#ifdef SPI_AVAILABLE</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>    <a class="code" href="unionspi__speed__t.html">spi_speed_t</a> speed = <a class="code" href="spi_8h.html#acc9bc29b3d7bfe41b8d81a0a24a7b8e8">SPI_SPEED_250KHZ</a>;
<a name="l00464"></a>00464     <a class="code" href="spi_8h.html#a7474753407c81142f127d725e22622ee" title="Initialisiert und aktiviert das SPI-Modul MCU = Master, Taktgeschwindigkeit F_CPU/2 (Maximum)...">SPI_MasterInit</a>(speed);
<a name="l00465"></a>00465 <span class="preprocessor">#else</span>
<a name="l00466"></a>00466 <span class="preprocessor"></span>    <a class="code" href="mmc-low_8h.html#a1caca2cc22bf414cd3aec841bc7b4120">MMC_CLK_DDR</a> |= _BV(<a class="code" href="mmc-low_8h.html#af3cfe48f6efdc257518227b43c1bc3df">SPI_CLK</a>);
<a name="l00467"></a>00467     <a class="code" href="mmc-low_8h.html#a6ff8677e9d28662f7e076dc8a6213467">MMC_DDR</a> = (uint8_t) (<a class="code" href="mmc-low_8h.html#a6ff8677e9d28662f7e076dc8a6213467">MMC_DDR</a> &amp; ~_BV(<a class="code" href="mmc-low_8h.html#a57666f9e6290a14874b7111990543ec2">SPI_DI</a>));
<a name="l00468"></a>00468     <a class="code" href="mmc-low_8h.html#a6ff8677e9d28662f7e076dc8a6213467">MMC_DDR</a> |= _BV(<a class="code" href="mmc-low_8h.html#a8c0bc6cc240b5384d0a3c3778a2b0b12">SPI_DO</a>);
<a name="l00469"></a>00469 <span class="preprocessor">#endif // SPI_AVAILABLE</span>
<a name="l00470"></a>00470 <span class="preprocessor"></span>    <a class="code" href="ena_8h.html#a51c24b2a246e1b3cbd3df73a7ac662ad">ENA_on</a>(<a class="code" href="ena_8h.html#a3ad1a6346c07216d560ebb698453d399">ENA_MMC</a>);
<a name="l00471"></a>00471     <a class="code" href="ena_8h.html#ac992908542eebed9776522f8eafc0ff9">ENA_off</a>(<a class="code" href="ena_8h.html#a3ad1a6346c07216d560ebb698453d399">ENA_MMC</a>);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473     <span class="comment">/* MMC/SD-Karte in den SPI-Mode initialisieren */</span>
<a name="l00474"></a>00474     int8_t <a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>;
<a name="l00475"></a>00475     <span class="keywordflow">for</span> (i = 16; i &gt;= 0; --<a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>) {
<a name="l00476"></a>00476         <span class="comment">// Sendet min. 74 Clocks an die MMC/SD-Karte</span>
<a name="l00477"></a>00477         <a class="code" href="mmc_8c.html#a33b293aa95d995d8903d5a687cb5e2a7">mmc_write_byte</a>(0xff);
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480     <span class="comment">/* Kommando CMD0 an MMC/SD-Karte senden */</span>
<a name="l00481"></a>00481     uint8_t cmd[] = { 0x40, 0x00, 0x00, 0x00, 0x00, 0x95 };
<a name="l00482"></a>00482     uint16_t timeout = 0;
<a name="l00483"></a>00483     <span class="keywordflow">while</span> (mmc_write_command(cmd) != 1) {
<a name="l00484"></a>00484         <span class="keywordflow">if</span> (timeout++ &gt; <a class="code" href="mmc-low_8h.html#abecee47f83881b14725d09934ca8e49e">MMC_TIMEOUT</a>) {
<a name="l00485"></a>00485             <a class="code" href="ena_8h.html#ac992908542eebed9776522f8eafc0ff9">ENA_off</a>(<a class="code" href="ena_8h.html#a3ad1a6346c07216d560ebb698453d399">ENA_MMC</a>);
<a name="l00486"></a>00486             <a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> = 1;
<a name="l00487"></a>00487 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00488"></a>00488 <span class="preprocessor"></span>            <a class="code" href="led_8h.html#a447c990bb9e81e6e533f0ba69f97b1e9">LED_on</a>(<a class="code" href="led_8h.html#abbd15a5aa331f751fc51e289ef51a82c">LED_TUERKIS</a>);
<a name="l00489"></a>00489 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span>            <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00491"></a>00491             <span class="keywordflow">return</span> 1; <span class="comment">// Abbruch bei Kommando 1 (Return Code 1)</span>
<a name="l00492"></a>00492         }
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495     <span class="comment">/* Kommando CMD1 an MMC/SD-Karte senden */</span>
<a name="l00496"></a>00496     timeout = 0;
<a name="l00497"></a>00497     cmd[0] = 0x41; <span class="comment">// Kommando 1</span>
<a name="l00498"></a>00498     cmd[5] = 0xFF; <span class="comment">// CRC</span>
<a name="l00499"></a>00499     <span class="keywordflow">while</span> (mmc_write_command(cmd) != 0) {
<a name="l00500"></a>00500         <span class="keywordflow">if</span> (timeout++ &gt; 6 * <a class="code" href="mmc-low_8h.html#abecee47f83881b14725d09934ca8e49e">MMC_TIMEOUT</a>) {
<a name="l00501"></a>00501             <a class="code" href="ena_8h.html#ac992908542eebed9776522f8eafc0ff9">ENA_off</a>(<a class="code" href="ena_8h.html#a3ad1a6346c07216d560ebb698453d399">ENA_MMC</a>);
<a name="l00502"></a>00502             <a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> = 1;
<a name="l00503"></a>00503 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00504"></a>00504 <span class="preprocessor"></span>            <a class="code" href="led_8h.html#a447c990bb9e81e6e533f0ba69f97b1e9">LED_on</a>(<a class="code" href="led_8h.html#abbd15a5aa331f751fc51e289ef51a82c">LED_TUERKIS</a>);
<a name="l00505"></a>00505 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00506"></a>00506 <span class="preprocessor"></span>            <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00507"></a>00507             <span class="keywordflow">return</span> 2; <span class="comment">// Abbruch bei Kommando 2 (Return Code 2)</span>
<a name="l00508"></a>00508         }
<a name="l00509"></a>00509     }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="preprocessor">#ifdef SPI_AVAILABLE</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span>    <a class="code" href="unionspi__speed__t.html">spi_speed_t</a> speed_high = <a class="code" href="spi_8h.html#a6bdb50b031934c65accc1b1b172ab006">SPI_SPEED_MAX</a>;
<a name="l00513"></a>00513     <a class="code" href="spi_8h.html#a7474753407c81142f127d725e22622ee" title="Initialisiert und aktiviert das SPI-Modul MCU = Master, Taktgeschwindigkeit F_CPU/2 (Maximum)...">SPI_MasterInit</a>(speed_high);
<a name="l00514"></a>00514 <span class="preprocessor">#endif // SPI_AVAILABLE</span>
<a name="l00515"></a>00515 <span class="preprocessor"></span>
<a name="l00516"></a>00516 <span class="preprocessor">#ifdef LED_AVAILABLE</span>
<a name="l00517"></a>00517 <span class="preprocessor"></span>    <a class="code" href="led_8h.html#abd7b28be86683943e4f3cea44ec0de76">LED_off</a>(<a class="code" href="led_8h.html#abbd15a5aa331f751fc51e289ef51a82c">LED_TUERKIS</a>);
<a name="l00518"></a>00518 <span class="preprocessor">#endif // LED_AVAILABLE</span>
<a name="l00519"></a>00519 <span class="preprocessor"></span>    <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00520"></a>00520     <span class="keywordflow">return</span> 0;
<a name="l00521"></a>00521 }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 <span class="preprocessor">#ifdef MMC_INFO_AVAILABLE</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span><span class="comment">//#ifdef DISPLAY_MMC_INFO</span>
<a name="l00526"></a>00526 <span class="comment"></span><span class="comment">// * Liest das CID-Register (16 Byte) von der Karte</span>
<a name="l00527"></a>00527 <span class="comment">// * \param *buffer Zeiger auf Puffer von mindestens 16 Byte</span>
<a name="l00528"></a>00528 <span class="comment">// * \return            0, falls alles OK</span>
<a name="l00529"></a>00529 <span class="comment">// */</span>
<a name="l00530"></a>00530 <span class="comment">//uint8_t mmc_read_cid(void * buffer) {</span>
<a name="l00531"></a>00531 <span class="comment">//  uint8_t cmd[] = {0x4A,0x00,0x00,0x00,0x00,0xFF}; // Kommando zum Lesen des CID Registers</span>
<a name="l00532"></a>00532 <span class="comment">//  if (mmc_read_block(cmd, buffer, 16) != 0) {</span>
<a name="l00533"></a>00533 <span class="comment">//      memset(buffer, 0, 16);</span>
<a name="l00534"></a>00534 <span class="comment">//      return 1;</span>
<a name="l00535"></a>00535 <span class="comment">//  }</span>
<a name="l00536"></a>00536 <span class="comment">//  return 0;</span>
<a name="l00537"></a>00537 <span class="comment">//}</span>
<a name="l00538"></a>00538 <span class="comment">//#endif // DISPLAY_MMC_INFO</span>
<a name="l00539"></a>00539 
<a name="l00545"></a>00545 uint8_t <a class="code" href="mmc_8h.html#aed36fbfaed816aaed3fcdec79797c8aa" title="Liest das CSD-Register (16 Byte) von der Karte.">mmc_read_csd</a>(<span class="keywordtype">void</span> * buffer) {
<a name="l00546"></a>00546     uint8_t cmd[] = {0x49,0x00,0x00,0x00,0x00,0xFF}; <span class="comment">// Kommando zum Lesen des CSD Registers</span>
<a name="l00547"></a>00547     uint8_t result = <a class="code" href="mmc_8h.html#a032097eb5e379d13ad27671730c01a80">mmc_read_block</a>(cmd, buffer, 16);
<a name="l00548"></a>00548     <span class="keywordflow">if</span> (result != 0) {
<a name="l00549"></a>00549         memset(buffer, result, 16);
<a name="l00550"></a>00550         <span class="keywordflow">return</span> 1;
<a name="l00551"></a>00551     }
<a name="l00552"></a>00552     <span class="keywordflow">return</span> 0;
<a name="l00553"></a>00553 }
<a name="l00554"></a>00554 
<a name="l00559"></a>00559 uint32_t <a class="code" href="mmc_8h.html#a9077f2369429106ec7271b08a39c33ee" title="Liefert die Groesse der Karte zurueck.">mmc_get_size</a>(<span class="keywordtype">void</span>) {
<a name="l00560"></a>00560     uint8_t csd[16];
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     <span class="keywordflow">if</span> (<a class="code" href="mmc_8h.html#aed36fbfaed816aaed3fcdec79797c8aa" title="Liest das CSD-Register (16 Byte) von der Karte.">mmc_read_csd</a>(csd) != 0) {
<a name="l00563"></a>00563         <span class="keywordflow">return</span> 0;
<a name="l00564"></a>00564     }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566     uint16_t size = (uint16_t)((csd[8] &gt;&gt; 6) + (csd[7] &lt;&lt; 2) + ((csd[6] &amp; 0x03) &lt;&lt; 10)); <span class="comment">// c_size</span>
<a name="l00567"></a>00567     size += 1; <span class="comment">// Fest in der Formel drin</span>
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     uint8_t shift = 2; <span class="comment">// eine 2 ist fest in der Formel drin</span>
<a name="l00570"></a>00570     shift = (uint8_t) (shift + (csd[10] &gt;&gt; 7) + ((csd[9] &amp; 0x03) &lt;&lt; 1)); <span class="comment">// c_size_mult beruecksichtigen</span>
<a name="l00571"></a>00571     shift = (uint8_t) (shift + (csd[5] &amp; 0x0f)); <span class="comment">// Blockgroesse beruecksichtigen</span>
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     uint32_t result = (uint32_t)size &lt;&lt; shift;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575     <span class="keywordflow">return</span> result;
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 <span class="preprocessor">#endif // MMC_INFO_AVAILABLE</span>
<a name="l00579"></a>00579 <span class="preprocessor"></span>
<a name="l00580"></a>00580 <span class="preprocessor">#ifdef MMC_WRITE_TEST_AVAILABLE</span>
<a name="l00581"></a>00581 <span class="preprocessor"></span>
<a name="l00587"></a>00587 uint8_t mmc_test(uint8_t * buffer) {
<a name="l00588"></a>00588     <span class="keyword">static</span> uint32_t sector = 0x20000;
<a name="l00589"></a>00589     <span class="comment">/* Initialisierung checken */</span>
<a name="l00590"></a>00590     <span class="keywordflow">if</span> (<a class="code" href="mmc_8h.html#affe9a50ec46df6b49325669ec060789e">mmc_init_state</a> != 0 &amp;&amp; <a class="code" href="mmc_8h.html#ae5fdd633809bced672d377c8504af7b6" title="Initialisiere die MMC/SD-Karte.">mmc_init</a>() != 0) {
<a name="l00591"></a>00591         <span class="keywordflow">return</span> 1;
<a name="l00592"></a>00592     }
<a name="l00593"></a>00593 <span class="preprocessor">#ifdef MMC_VM_AVAILABLE // Version mit virtuellen Aressen</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span>    uint16_t <a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>;
<a name="l00595"></a>00595     <span class="keyword">static</span> uint16_t pagefaults = 0;
<a name="l00596"></a>00596     <span class="keyword">static</span> uint16_t old_pf;
<a name="l00597"></a>00597     <span class="comment">/* virtuelle Adressen holen */</span>
<a name="l00598"></a>00598     <span class="keyword">static</span> uint32_t v_addr1 = 0;
<a name="l00599"></a>00599     <span class="keyword">static</span> uint32_t v_addr2 = 0;
<a name="l00600"></a>00600     <span class="keyword">static</span> uint32_t v_addr3 = 0;
<a name="l00601"></a>00601     <span class="keyword">static</span> uint32_t v_addr4 = 0;
<a name="l00602"></a>00602     <span class="keywordflow">if</span> (v_addr1 == 0) v_addr1 = <a class="code" href="mmc-vm_8c.html#a451514920748291271c1ee5f671f5503">mmcalloc</a>(512, 1); <span class="comment">// Testdaten 1</span>
<a name="l00603"></a>00603     <span class="keywordflow">if</span> (v_addr2 == 0) v_addr2 = <a class="code" href="mmc-vm_8c.html#a451514920748291271c1ee5f671f5503">mmcalloc</a>(512, 1); <span class="comment">// Testdaten 2</span>
<a name="l00604"></a>00604     <span class="keywordflow">if</span> (v_addr3 == 0) v_addr3 = <a class="code" href="mmc-vm_8c.html#a451514920748291271c1ee5f671f5503">mmcalloc</a>(512, 1); <span class="comment">// Dummy 1</span>
<a name="l00605"></a>00605     <span class="keywordflow">if</span> (v_addr4 == 0) v_addr4 = <a class="code" href="mmc-vm_8c.html#a451514920748291271c1ee5f671f5503">mmcalloc</a>(512, 1); <span class="comment">// Dummy 2</span>
<a name="l00606"></a>00606     <span class="comment">/* Zeitmessung starten */</span>
<a name="l00607"></a>00607     uint16_t start_ticks=<a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00608"></a>00608     uint8_t start_reg=TCNT2;
<a name="l00609"></a>00609     <span class="comment">/* Pointer auf Puffer holen */</span>
<a name="l00610"></a>00610     uint8_t * p_addr = <a class="code" href="mmc-vm_8c.html#a25aa2c381c261acbae31715c03056db9">mmc_get_data</a>(v_addr1); <span class="comment">// Cache-Hit, CB 0</span>
<a name="l00611"></a>00611     <span class="keywordflow">if</span> (p_addr == NULL) <span class="keywordflow">return</span> 2;
<a name="l00612"></a>00612     <span class="comment">/* Testdaten schreiben */</span>
<a name="l00613"></a>00613     <span class="keywordflow">for</span> (i=0; i&lt;512; i++)
<a name="l00614"></a>00614     p_addr[i] = (i &amp; 0xff);
<a name="l00615"></a>00615     <span class="comment">/* Pointer auf zweiten Speicherbereich holen */</span>
<a name="l00616"></a>00616     p_addr = <a class="code" href="mmc-vm_8c.html#a25aa2c381c261acbae31715c03056db9">mmc_get_data</a>(v_addr2); <span class="comment">// Cache-Hit, CB 1</span>
<a name="l00617"></a>00617     <span class="keywordflow">if</span> (p_addr == NULL) <span class="keywordflow">return</span> 3;
<a name="l00618"></a>00618     <span class="comment">/* Testdaten Teil 2 schreiben */</span>
<a name="l00619"></a>00619     <span class="keywordflow">for</span> (i=0; i&lt;512; i++)
<a name="l00620"></a>00620     p_addr[i] = 255 - (i &amp; 0xff);
<a name="l00621"></a>00621     <span class="comment">/* kleiner LRU-Test */</span>
<a name="l00622"></a>00622     <span class="comment">//          p_addr = mmc_get_data(v_addr1); // Cache-Hit, CB 0</span>
<a name="l00623"></a>00623     <span class="comment">//          p_addr = mmc_get_data(v_addr4); // Cache-Miss, =&gt; CB 1</span>
<a name="l00624"></a>00624     <span class="comment">//          p_addr = mmc_get_data(v_addr1); // Cache-Hit, CB 0</span>
<a name="l00625"></a>00625     <span class="comment">//          p_addr = mmc_get_data(v_addr3); // Cache-Miss, =&gt; CB 1</span>
<a name="l00626"></a>00626     <span class="comment">//          p_addr = mmc_get_data(v_addr1); // Cache-Hit, CB 0</span>
<a name="l00627"></a>00627     <span class="comment">//          p_addr = mmc_get_data(v_addr4); // Cache-Miss, =&gt; CB 1</span>
<a name="l00628"></a>00628     <span class="comment">/* Pointer auf Testdaten Teil 1 holen */</span>
<a name="l00629"></a>00629     p_addr = <a class="code" href="mmc-vm_8c.html#a25aa2c381c261acbae31715c03056db9">mmc_get_data</a>(v_addr1); <span class="comment">// Cache-Hit, CB 0</span>
<a name="l00630"></a>00630     <span class="keywordflow">if</span> (p_addr == NULL) <span class="keywordflow">return</span> 4;
<a name="l00631"></a>00631     <span class="comment">/* Testdaten 1 vergleichen */</span>
<a name="l00632"></a>00632     <span class="keywordflow">for</span> (i=0; i&lt;512; i++)
<a name="l00633"></a>00633     <span class="keywordflow">if</span> (p_addr[i] != (i &amp; 0xff)) <span class="keywordflow">return</span> 5;
<a name="l00634"></a>00634     <span class="comment">/* Pointer auf Testdaten Teil 2 holen */</span>
<a name="l00635"></a>00635     p_addr = <a class="code" href="mmc-vm_8c.html#a25aa2c381c261acbae31715c03056db9">mmc_get_data</a>(v_addr2); <span class="comment">// Cache-Miss, =&gt; CB 1</span>
<a name="l00636"></a>00636     <span class="keywordflow">if</span> (p_addr == NULL) <span class="keywordflow">return</span> 6;
<a name="l00637"></a>00637     <span class="comment">/* Testdaten 2 vergleichen */</span>
<a name="l00638"></a>00638     <span class="keywordflow">for</span> (i=0; i&lt;512; i++)
<a name="l00639"></a>00639     <span class="keywordflow">if</span> (p_addr[i] != (255 - (i &amp; 0xff))) <span class="keywordflow">return</span> 7;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641     p_addr = <a class="code" href="mmc-vm_8c.html#a25aa2c381c261acbae31715c03056db9">mmc_get_data</a>(v_addr4);
<a name="l00642"></a>00642     <span class="comment">/* Zeitmessung beenden */</span>
<a name="l00643"></a>00643     int8_t timer_reg=TCNT2;
<a name="l00644"></a>00644     uint16_t end_ticks=<a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00645"></a>00645     timer_reg -= start_reg;
<a name="l00646"></a>00646 <span class="preprocessor">#ifdef VM_STATS_AVAILABLE</span>
<a name="l00647"></a>00647 <span class="preprocessor"></span>    <span class="comment">/* Pagefaults merken */</span>
<a name="l00648"></a>00648     old_pf = pagefaults;
<a name="l00649"></a>00649     pagefaults = mmc_get_pagefaults();
<a name="l00650"></a>00650 <span class="preprocessor">#endif</span>
<a name="l00651"></a>00651 <span class="preprocessor"></span>    <span class="comment">/* kleine Statistik ausgeben */</span>
<a name="l00652"></a>00652     <a class="code" href="display_8h.html#ad5109335e4419b07f4d9f73db290f2eb">display_cursor</a>(3, 1);
<a name="l00653"></a>00653     <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;Pagefaults: %5u   &quot;</span>, pagefaults);
<a name="l00654"></a>00654     <a class="code" href="display_8h.html#ad5109335e4419b07f4d9f73db290f2eb">display_cursor</a>(4, 1);
<a name="l00655"></a>00655     <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;Bei %3u PF: %5u us&quot;</span>, pagefaults - old_pf, (end_ticks-start_ticks)*176 + timer_reg*4);
<a name="l00656"></a>00656 <span class="preprocessor">#else // alte Version</span>
<a name="l00657"></a>00657 <span class="preprocessor"></span>    uint16_t <a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>;
<a name="l00658"></a>00658     uint8_t result = 0;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     <span class="comment">/* Zeitmessung */</span>
<a name="l00661"></a>00661     uint16_t start_ticks;
<a name="l00662"></a>00662     uint16_t end_ticks;
<a name="l00663"></a>00663     <span class="keyword">static</span> uint32_t time_read = 0;
<a name="l00664"></a>00664     <span class="keyword">static</span> uint32_t time_write = 0;
<a name="l00665"></a>00665     <span class="keyword">static</span> uint32_t <a class="code" href="behaviour__drive__chess_8c.html#aa94ff7ddd304b9beb2f209b6174e180e">n</a> = 0;
<a name="l00666"></a>00666 
<a name="l00667"></a>00667     <span class="comment">// Puffer vorbereiten</span>
<a name="l00668"></a>00668     <span class="keywordflow">for</span> (i = 0; i &lt; 512; i++) {
<a name="l00669"></a>00669         buffer[<a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>] = (uint8_t)(i &amp; 0xff);
<a name="l00670"></a>00670     }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672     <span class="comment">/* Zeitmessung starten */</span>
<a name="l00673"></a>00673     start_ticks = <a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00674"></a>00674 
<a name="l00675"></a>00675     <span class="comment">// und schreiben</span>
<a name="l00676"></a>00676     result = <a class="code" href="mmc_8h.html#a8b7742b9c060af7db1aa56e1d9676918">mmc_write_sector</a>(sector, buffer);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     <span class="comment">/* Zeitmessung beenden */</span>
<a name="l00679"></a>00679     end_ticks = <a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00680"></a>00680     time_write = time_write + (uint16_t) ((end_ticks - start_ticks) * 176<a class="code" href="behaviour__drive__chess_8c.html#affc9cbf86b78292bdb405361761c47f5">U</a>);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="keywordflow">if</span> (result != 0) {
<a name="l00683"></a>00683         <span class="keywordflow">return</span> (uint8_t) (result * 10 + 2);
<a name="l00684"></a>00684     }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     <span class="comment">// Puffer vorbereiten</span>
<a name="l00687"></a>00687     <span class="keywordflow">for</span> (i = 0; i &lt; 512; i++) {
<a name="l00688"></a>00688         buffer[<a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>] = (uint8_t) (255 - (i &amp; 0xff));
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691     <span class="comment">/* Zeitmessung starten */</span>
<a name="l00692"></a>00692     start_ticks = <a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694     <span class="comment">// und schreiben</span>
<a name="l00695"></a>00695     result = <a class="code" href="mmc_8h.html#a8b7742b9c060af7db1aa56e1d9676918">mmc_write_sector</a>(sector + 1, buffer);
<a name="l00696"></a>00696 
<a name="l00697"></a>00697     <span class="comment">/* Zeitmessung beenden */</span>
<a name="l00698"></a>00698     end_ticks = <a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00699"></a>00699     time_write = time_write + (uint16_t) ((end_ticks - start_ticks) * 176<a class="code" href="behaviour__drive__chess_8c.html#affc9cbf86b78292bdb405361761c47f5">U</a>);
<a name="l00700"></a>00700 
<a name="l00701"></a>00701     <span class="keywordflow">if</span> (result != 0) {
<a name="l00702"></a>00702         <span class="keywordflow">return</span> (uint8_t) (result * 10 + 3);
<a name="l00703"></a>00703     }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705     <span class="comment">/* Zeitmessung starten */</span>
<a name="l00706"></a>00706     start_ticks = <a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     <span class="comment">// Puffer lesen</span>
<a name="l00709"></a>00709     result = <a class="code" href="mmc_8h.html#a7ebc2ededd906eb69ecc1d14e2caae45">mmc_read_sector</a>(sector++, buffer);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711     <span class="comment">/* Zeitmessung beenden */</span>
<a name="l00712"></a>00712     end_ticks = <a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00713"></a>00713     time_read = time_read + (uint16_t) ((end_ticks - start_ticks) * 176<a class="code" href="behaviour__drive__chess_8c.html#affc9cbf86b78292bdb405361761c47f5">U</a>);
<a name="l00714"></a>00714 
<a name="l00715"></a>00715     <span class="keywordflow">if</span> (result != 0) {
<a name="l00716"></a>00716         sector--;
<a name="l00717"></a>00717         <span class="keywordflow">return</span> (uint8_t) (result * 10 + 4);
<a name="l00718"></a>00718     }
<a name="l00719"></a>00719 
<a name="l00720"></a>00720     <span class="comment">// und vergleichen</span>
<a name="l00721"></a>00721     <span class="keywordflow">for</span> (i = 0; i &lt; 512; i++) {
<a name="l00722"></a>00722         <span class="keywordflow">if</span> (buffer[i] != (i &amp; 0xFF)) {
<a name="l00723"></a>00723             <a class="code" href="log_8h.html#af3fb0ee7384d6813437103a2c2646fb7">LOG_ERROR</a>(<span class="stringliteral">&quot;i:%u\tread:0x%x\texpected:0x%x&quot;</span>, i, buffer[i], i &amp; 0xff);
<a name="l00724"></a>00724             <span class="keywordflow">return</span> 5;
<a name="l00725"></a>00725         }
<a name="l00726"></a>00726     }
<a name="l00727"></a>00727 
<a name="l00728"></a>00728     <span class="comment">/* Zeitmessung starten */</span>
<a name="l00729"></a>00729     start_ticks = <a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731     <span class="comment">// Puffer lesen</span>
<a name="l00732"></a>00732     result = <a class="code" href="mmc_8h.html#a7ebc2ededd906eb69ecc1d14e2caae45">mmc_read_sector</a>(sector++, buffer);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734     <span class="comment">/* Zeitmessung beenden */</span>
<a name="l00735"></a>00735     end_ticks = <a class="code" href="timer_8h.html#a18263e68cde6252d694ac588634e05bd">TIMER_GET_TICKCOUNT_16</a>;
<a name="l00736"></a>00736     time_read = time_read + (uint16_t) ((end_ticks - start_ticks) * 176<a class="code" href="behaviour__drive__chess_8c.html#affc9cbf86b78292bdb405361761c47f5">U</a>);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     <span class="keywordflow">if</span> (result != 0) {
<a name="l00739"></a>00739         sector--;
<a name="l00740"></a>00740         <span class="keywordflow">return</span> (uint8_t) (result * 10 + 6);
<a name="l00741"></a>00741     }
<a name="l00742"></a>00742     <span class="comment">// und vergleichen</span>
<a name="l00743"></a>00743     <span class="keywordflow">for</span> (i = 0; i &lt; 512; i++) {
<a name="l00744"></a>00744         <span class="keywordflow">if</span> (buffer[i] != (255 - (i &amp; 0xFF))) {
<a name="l00745"></a>00745             <a class="code" href="log_8h.html#af3fb0ee7384d6813437103a2c2646fb7">LOG_ERROR</a>(<span class="stringliteral">&quot;i:%u\tread:0x%x\texpected:0x%x&quot;</span>, i, buffer[i], 255 - (i &amp; 0xff));
<a name="l00746"></a>00746             <span class="keywordflow">return</span> 7;
<a name="l00747"></a>00747         }
<a name="l00748"></a>00748     }
<a name="l00749"></a>00749 
<a name="l00750"></a>00750     <span class="comment">/* kleine Statistik ausgeben */</span>
<a name="l00751"></a>00751     <a class="code" href="os__thread_8h.html#a29e5f7c4cb7a64b0d9157f2a9efdcdc5" title="Schuetzt den folgenden Block (bis os_exitCS()) vor Threadswitches.">os_enterCS</a>();
<a name="l00752"></a>00752     <a class="code" href="display_8h.html#ad5109335e4419b07f4d9f73db290f2eb">display_cursor</a>(3, 1);
<a name="l00753"></a>00753     n += 2;
<a name="l00754"></a>00754     <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;Dauer r/w%5u/%5u&quot;</span>, (uint16_t) (time_read / n), (uint16_t) (time_write / n));
<a name="l00755"></a>00755     <a class="code" href="display_8h.html#ad5109335e4419b07f4d9f73db290f2eb">display_cursor</a>(4, 1);
<a name="l00756"></a>00756     <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;Sektor: 0x%04x&quot;</span>, (sector-2) &gt;&gt; 16);
<a name="l00757"></a>00757     <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;%04x  &quot;</span>, (sector-2) &amp; 0xffff);
<a name="l00758"></a>00758     <a class="code" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.">os_exitCS</a>();
<a name="l00759"></a>00759 <span class="preprocessor">#endif // MMC_VM_AVAILABLE</span>
<a name="l00760"></a>00760 <span class="preprocessor"></span>    <span class="comment">// hierher kommen wir nur, wenn alles ok ist</span>
<a name="l00761"></a>00761     <span class="keywordflow">return</span> 0;
<a name="l00762"></a>00762 }
<a name="l00763"></a>00763 <span class="preprocessor">#endif // MMC_WRITE_TEST_AVAILABLE</span>
<a name="l00764"></a>00764 <span class="preprocessor"></span>
<a name="l00765"></a>00765 <span class="preprocessor">#ifdef DISPLAY_MMC_INFO</span>
<a name="l00766"></a>00766 <span class="preprocessor"></span>
<a name="l00769"></a>00769 <span class="keywordtype">void</span> mmc_display(<span class="keywordtype">void</span>) {
<a name="l00770"></a>00770 <span class="preprocessor">#ifdef MMC_INFO_AVAILABLE</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span>    <span class="keyword">static</span> uint8_t mmc_state = 0xff;
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     uint8_t dummy = <a class="code" href="mmc_8h.html#ae5fdd633809bced672d377c8504af7b6" title="Initialisiere die MMC/SD-Karte.">mmc_init</a>();
<a name="l00774"></a>00774     <span class="comment">/* hat sich was geaendert? */</span>
<a name="l00775"></a>00775     <span class="keywordflow">if</span> (dummy != mmc_state) {
<a name="l00776"></a>00776         mmc_state = dummy;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778         <a class="code" href="display_8h.html#ad5109335e4419b07f4d9f73db290f2eb">display_cursor</a>(1, 1);
<a name="l00779"></a>00779         <span class="keywordflow">if</span> (mmc_state != 0) {
<a name="l00780"></a>00780             <a class="code" href="display_8h.html#a336e8b1e4fcf1785ec84e0eed492c418" title="Loescht das ganze Display.">display_clear</a>();
<a name="l00781"></a>00781             <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;MMC not init (%u)&quot;</span>, mmc_state);
<a name="l00782"></a>00782             <span class="keywordflow">return</span>;
<a name="l00783"></a>00783         }
<a name="l00784"></a>00784         uint32_t size = <a class="code" href="mmc_8h.html#a9077f2369429106ec7271b08a39c33ee" title="Liefert die Groesse der Karte zurueck.">mmc_get_size</a>();
<a name="l00785"></a>00785         <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;  MMC: %4u MByte &quot;</span>, size &gt;&gt; 20);
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="preprocessor">#ifndef MMC_WRITE_TEST_AVAILABLE</span>
<a name="l00788"></a>00788 <span class="preprocessor"></span>        uint8_t csd[16];
<a name="l00789"></a>00789         <a class="code" href="mmc_8h.html#aed36fbfaed816aaed3fcdec79797c8aa" title="Liest das CSD-Register (16 Byte) von der Karte.">mmc_read_csd</a>(csd);
<a name="l00790"></a>00790         <a class="code" href="display_8h.html#ad5109335e4419b07f4d9f73db290f2eb">display_cursor</a>(3, 1);
<a name="l00791"></a>00791         uint8_t <a class="code" href="behaviour__drive__chess_8c.html#a9aa40e637eff435d9abc0f4dc467b6bb">i</a>;
<a name="l00792"></a>00792         <span class="keywordflow">for</span> (i=0; i&lt;16; i++) {
<a name="l00793"></a>00793             <span class="keywordflow">if</span> (i == 8) <a class="code" href="display_8h.html#ad5109335e4419b07f4d9f73db290f2eb">display_cursor</a>(4, 1);
<a name="l00794"></a>00794             <span class="keywordflow">if</span> (i%2 == 0) <a class="code" href="display_8h.html#ac5ba4c9512c407150e76ef8b97910271">display_puts</a>(<span class="stringliteral">&quot; &quot;</span>);
<a name="l00795"></a>00795             <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;%02x&quot;</span>, csd[i]);
<a name="l00796"></a>00796         }
<a name="l00797"></a>00797 <span class="preprocessor">#endif // MMC_WRITE_TEST_AVAILABLE</span>
<a name="l00798"></a>00798 <span class="preprocessor"></span>    }
<a name="l00799"></a>00799 <span class="preprocessor">#ifdef MMC_WRITE_TEST_AVAILABLE</span>
<a name="l00800"></a>00800 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (mmc_state == 0) {
<a name="l00801"></a>00801         <span class="keyword">static</span> uint8_t buffer[512];
<a name="l00802"></a>00802         uint8_t result = mmc_test(buffer);
<a name="l00803"></a>00803         <span class="keywordflow">if</span> (result != 0) {
<a name="l00804"></a>00804             <a class="code" href="display_8h.html#ad5109335e4419b07f4d9f73db290f2eb">display_cursor</a>(3, 1);
<a name="l00805"></a>00805             <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;mmc_test()=%u :(&quot;</span>, result);
<a name="l00806"></a>00806         }
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808 <span class="preprocessor">#endif // MMC_WRITE_TEST_AVAILABLE</span>
<a name="l00809"></a>00809 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00810"></a>00810 <span class="preprocessor"></span><span class="preprocessor">#ifdef MMC_VM_AVAILABLE</span>
<a name="l00811"></a>00811 <span class="preprocessor"></span><span class="preprocessor">#ifdef PC</span>
<a name="l00812"></a>00812 <span class="preprocessor"></span>    <a class="code" href="display_8h.html#ad5109335e4419b07f4d9f73db290f2eb">display_cursor</a>(3, 1);
<a name="l00813"></a>00813     <a class="code" href="display_8h.html#a3b34665813cc31ce81d141e4f67162d2">display_printf</a>(<span class="stringliteral">&quot;mmc_emu_test() = %u &quot;</span>, <a class="code" href="mmc-emu_8h.html#a45b6d2d38a37d8d929ed6b9233e18fe7">mmc_emu_test</a>());
<a name="l00814"></a>00814 <span class="preprocessor">#endif // PC</span>
<a name="l00815"></a>00815 <span class="preprocessor"></span><span class="preprocessor">#endif // MMC_VM_AVAILABLE</span>
<a name="l00816"></a>00816 <span class="preprocessor"></span><span class="preprocessor">#endif // MMC_INFO_AVAILABLE</span>
<a name="l00817"></a>00817 <span class="preprocessor"></span>}
<a name="l00818"></a>00818 <span class="preprocessor">#endif // DISPLAY_MMC_INFO</span>
<a name="l00819"></a>00819 <span class="preprocessor"></span>
<a name="l00820"></a>00820 <span class="preprocessor">#endif // MMC_AVAILABLE</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span><span class="preprocessor">#endif // MCU</span>
</pre></div></div>
</div>


<hr class="footer"/><address class="footer"><small>
Erzeugt am Mit Feb 29 2012 14:18:09 f√ºr c't-Bot von &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
