<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>c&#39;t-Bot: os_thread.c-Dateireferenz</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">c&#39;t-Bot
   &#160;<span id="projectnumber">1898</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Erzeugt von Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Hauptseite</span></a></li>
      <li><a href="pages.html"><span>Zusätzliche&#160;Informationen</span></a></li>
      <li><a href="annotated.html"><span>Datenstrukturen</span></a></li>
      <li class="current"><a href="files.html"><span>Dateien</span></a></li>
      <li><a href="dirs.html"><span>Verzeichnisse</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Auflistung&#160;der&#160;Dateien</span></a></li>
      <li><a href="globals.html"><span>Datei-Elemente</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_f02428e3da713fc394853d6cd2afbcd0.html">mcu</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Datenstrukturen</a> &#124;
<a href="#func-members">Funktionen</a> &#124;
<a href="#var-members">Variablen</a>  </div>
  <div class="headertitle">
<div class="title">os_thread.c-Dateireferenz</div>  </div>
</div>
<div class="contents">

<p>Threadmanagement fuer BotOS.  
<a href="#details">Mehr ...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ct-Bot_8h_source.html">ct-Bot.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="os__thread_8h_source.html">os_thread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="os__utils_8h_source.html">os_utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="log_8h_source.html">log.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="map_8h_source.html">map.h</a>&quot;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include-Abhängigkeitsdiagramm für os_thread.c:</div>
<div class="dyncontent">
<div class="center"><img src="os__thread_8c__incl.png" border="0" usemap="#os__thread_8c" alt=""/></div>
<map name="os__thread_8c" id="os__thread_8c">
<area shape="rect" id="node3" href="ct-Bot_8h.html" title="globale Schalter fuer die einzelnen Bot&#45;Funktionalitaeten" alt="" coords="1645,238,1712,266"/><area shape="rect" id="node23" href="os__thread_8h.html" title="Threadmanagement fuer BotOS." alt="" coords="5912,238,6003,266"/><area shape="rect" id="node31" href="os__utils_8h.html" title="Hilfsfunktionen fuer BotOS." alt="" coords="5939,83,6016,111"/><area shape="rect" id="node33" href="log_8h.html" title="Routinen zum Loggen von Informationen." alt="" coords="6040,83,6091,111"/><area shape="rect" id="node35" href="map_8h.html" title="Karte." alt="" coords="5749,83,5808,111"/><area shape="rect" id="node5" href="global_8h.html" title="Allgemeine Definitionen und Datentypen." alt="" coords="315,315,384,343"/><area shape="rect" id="node21" href="bot-local_8h.html" title="Konstanten, die den Bot an reale Umgebungen anpassen." alt="" coords="408,315,493,343"/><area shape="rect" id="node11" href="builtins_8h.html" title="Compiler&#45;Builtins mit Fallback fuer aeltere avr&#45;libc Versionen." alt="" coords="19,393,91,421"/><area shape="rect" id="node27" href="timer_8h.html" title="Timer und Zaehler." alt="" coords="6020,315,6081,343"/><area shape="rect" id="node29" href="os__scheduler_8h.html" title="Mini&#45;Scheduler fuer BotOS." alt="" coords="5783,315,5895,343"/><area shape="rect" id="node37" href="bot-logic_8h.html" title="High&#45;Level&#45;Routinen fuer die Steuerung des c&#39;t&#45;Bots." alt="" coords="5352,161,5493,189"/><area shape="rect" id="node91" href="fifo_8h.html" title="Implementierung einer FIFO." alt="" coords="5816,161,5864,189"/><area shape="rect" id="node95" href="botfs_8h.html" title="Dateisystem BotFS." alt="" coords="5680,161,5741,189"/><area shape="rect" id="node40" href="motor_8h.html" title="High&#45;Level Routinen fuer die Motorsteuerung des c&#39;t&#45;Bots." alt="" coords="3936,393,4003,421"/><area shape="rect" id="node42" href="sensor_8h.html" title="Architekturunabhaengiger Teil der Sensorsteuerung." alt="" coords="5387,238,5459,266"/><area shape="rect" id="node48" href="available__behaviours_8h.html" title="globale Schalter fuer die einzelnen Verhalten" alt="" coords="2964,238,3183,266"/><area shape="rect" id="node44" href="rc5_8h.html" title="RC5&#45;Fernbedienung / Basic&#45;Tasten&#45;Handler." alt="" coords="5448,315,5499,343"/><area shape="rect" id="node46" href="cmps03_8h.html" title="CMPS03&#45;Treiber." alt="" coords="5344,315,5424,343"/><area shape="rect" id="node50" href="behaviour__prototype_8h.html" title="Rohling fuer eigene Verhalten." alt="" coords="2515,315,2728,343"/><area shape="rect" id="node52" href="behaviour__hw__test_8h.html" title="Testcode fuer die Bot&#45;Hardware (ehemals TEST_AVAILABLE_ANALOG, _DIGITAL, _MOTOR)" alt="" coords="2752,315,2952,343"/><area shape="rect" id="node54" href="behaviour__simple_8h.html" title="ganz einfache Beispielverhalten Diese Datei sollte der Einstiegspunkt fuer eigene Experimente sein..." alt="" coords="2976,315,3171,343"/><area shape="rect" id="node56" href="behaviour__drive__square_8h.html" title="Bot faehrt im Quadrat." alt="" coords="3195,315,3429,343"/><area shape="rect" id="node58" href="behaviour__avoid__border_8h.html" title="Vermeide Abgruende." alt="" coords="3453,315,3691,343"/><area shape="rect" id="node60" href="behaviour__avoid__col_8h.html" title="Vermeide Kollisionen." alt="" coords="3715,315,3928,343"/><area shape="rect" id="node62" href="behaviour__hang__on_8h.html" title="Haengenbleiben Notfallverhalten." alt="" coords="3952,315,4160,343"/><area shape="rect" id="node64" href="behaviour__goto_8h.html" title="Bot faehrt einen Punkt an." alt="" coords="4184,315,4365,343"/><area shape="rect" id="node66" href="behaviour__gotoxy_8h.html" title="Bot faehrt eine Position an." alt="" coords="4389,315,4587,343"/><area shape="rect" id="node68" href="behaviour__goto__pos_8h.html" title="Anfahren einer Position." alt="" coords="4611,315,4824,343"/><area shape="rect" id="node70" href="behaviour__goto__obstacle_8h.html" title="Anfahren eines Hindernisses." alt="" coords="4848,315,5091,343"/><area shape="rect" id="node72" href="behaviour__turn_8h.html" title="Drehe den Bot." alt="" coords="2315,315,2491,343"/><area shape="rect" id="node75" href="behaviour__turn__test_8h.html" title="Fuehrt mehrere Drehungen mit bot_turn() aus und misst die Fehler." alt="" coords="5115,315,5320,343"/><area shape="rect" id="node77" href="behaviour__drive__distance_8h.html" title="Bot faehrt ein Stueck." alt="" coords="517,315,760,343"/><area shape="rect" id="node79" href="behaviour__measure__distance_8h.html" title="Ermittelt die aktuelle Entfernung eines Hindernisses mit den Distanzsensoren." alt="" coords="784,315,1051,343"/><area shape="rect" id="node81" href="behaviour__scan_8h.html" title="Scannt die Umgebung und traegt sie in die Karte ein." alt="" coords="1075,315,1259,343"/><area shape="rect" id="node83" href="behaviour__solve__maze_8h.html" title="Wandfolger durchs Labyrinth." alt="" coords="1283,315,1512,343"/><area shape="rect" id="node85" href="behaviour__follow__line_8h.html" title="Linienverfolger." alt="" coords="1536,315,1755,343"/><area shape="rect" id="node87" href="behaviour__follow__line__enhanced_8h.html" title="erweiterter Linienverfolger, der auch mit Unterbrechungen und Hindernissen klarkommt" alt="" coords="1779,315,2064,343"/><area shape="rect" id="node89" href="behaviour__olympic_8h.html" title="Bot sucht Saeulen und faehrt dann Slalom." alt="" coords="2088,315,2291,343"/><area shape="rect" id="node97" href="botfs__config_8h.html" title="Konfig&#45;Optionen fuer Dateisystem BotFS." alt="" coords="5659,238,5763,266"/><area shape="rect" id="node99" href="botfs__types_8h.html" title="Datentypen fuer Dateisystem BotFS." alt="" coords="5787,238,5888,266"/></map>
</div>
</div>
<p><a href="os__thread_8c_source.html">gehe zum Quellcode dieser Datei</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Datenstrukturen</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionos__ip__t.html">os_ip_t</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Funktionen</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTcb__t.html">Tcb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#a2225be2eb34882c09ae7ad31a8b07207">os_create_thread</a> (void *pStack, void(*pIp)(void))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Legt einen neuen Thread an und setzt ihn auf runnable.  <a href="#a2225be2eb34882c09ae7ad31a8b07207"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#a146cd9b383b02d8e5424e2de5bfdf7e1">os_exitCS</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Beendet den kritischen Abschnitt wieder, der mit os_enterCS began.  <a href="#a146cd9b383b02d8e5424e2de5bfdf7e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#af29e431cbca02833132a67de16011925">os_thread_yield</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#aa62b6d29ae00ff288fd8969807a62b06">os_signal_set</a> (<a class="el" href="structos__signal__t.html">os_signal_t</a> *signal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blockiert den aktuellen Thread, bis ein Signal freigegeben wird.  <a href="#aa62b6d29ae00ff288fd8969807a62b06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#afa82438e9832609bc5ffbddad166e1b7">os_switch_thread</a> (<a class="el" href="structTcb__t.html">Tcb_t</a> *from, <a class="el" href="structTcb__t.html">Tcb_t</a> *to)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schaltet "von aussen" auf einen neuen Thread um.  <a href="#afa82438e9832609bc5ffbddad166e1b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#ac0440fe078802d66f53552e2eaec35fb">os_mask_stack</a> (void *stack, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#a03112bc663383c20072a345d7648e89c">os_print_stackusage</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#a772b2312a1edbfeeb3e41510b5e62ef9">os_stack_dump</a> (<a class="el" href="structTcb__t.html">Tcb_t</a> *thread, void *stack, uint16_t size)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variablen</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTcb__t.html">Tcb_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#a98e9aac6030735e7a03aa7b3681c43a2">os_threads</a> [OS_MAX_THREADS]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-Pool (ist gleichzeitig running- und waiting-queue)  <a href="#a98e9aac6030735e7a03aa7b3681c43a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTcb__t.html">Tcb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#aa7c832fad63b24918265cadcd962e5ab">os_thread_running</a> = NULL</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeiger auf den Thread, der zurzeit laeuft.  <a href="#aa7c832fad63b24918265cadcd962e5ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#a684b331eb0a74daf505e2ae7e9f1bb64">os_kernel_stack</a> [OS_KERNEL_STACKSIZE]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel-Stack.  <a href="#a684b331eb0a74daf505e2ae7e9f1bb64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structos__signal__t.html">os_signal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os__thread_8c.html#a106f72a08737e37e3b19428051f6b8f7">dummy_signal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal, das referenziert wird, wenn sonst keins gesetzt ist.  <a href="#a106f72a08737e37e3b19428051f6b8f7"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Ausführliche Beschreibung</h2>
<div class="textblock"><p>Threadmanagement fuer BotOS. </p>
<dl class="author"><dt><b>Autor:</b></dt><dd>Timo Sandmann (<a href="mailto:mail@timosandmann.de">mail@timosandmann.de</a>) </dd></dl>
<dl class="date"><dt><b>Datum:</b></dt><dd>02.10.2007 </dd></dl>

<p>Definiert in Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>
</div><hr/><h2>Dokumentation der Funktionen</h2>
<a class="anchor" id="a2225be2eb34882c09ae7ad31a8b07207"></a><!-- doxytag: member="os_thread.c::os_create_thread" ref="a2225be2eb34882c09ae7ad31a8b07207" args="(void *pStack, void(*pIp)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTcb__t.html">Tcb_t</a>* os_create_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pIp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Legt einen neuen Thread an und setzt ihn auf runnable. </p>
<p>Legt einen neuen Thread an. Der zuerst angelegt Thread bekommt die hoechste Prioritaet, je spaeter ein Thread erzeugt wird, desto niedriger ist seine Prioritaet, das laesst sich auch nicht mehr aendern! </p>
<dl><dt><b>Parameter:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*pStack</td><td>Zeiger auf den Stack (Ende!) des neuen Threads </td></tr>
    <tr><td class="paramname">*pIp</td><td>Zeiger auf die Main-Funktion des Threads (Instruction-Pointer) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Rückgabe:</b></dt><dd>Zeiger auf den TCB des angelegten Threads </dd></dl>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00065">65</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Benutzt <a class="el" href="unionos__ip__t.html#acf44de7f2ffeba1fa016e064cc6c190e">os_ip_t::bytes</a>, <a class="el" href="os__thread_8c_source.html#l00054">dummy_signal</a>, <a class="el" href="os__thread_8c_source.html#l00047">os_ip_t::hi8</a>, <a class="el" href="behaviour__drive__chess_8c_source.html#l00175">i</a>, <a class="el" href="os__thread_8c_source.html#l00044">os_ip_t::ip</a>, <a class="el" href="os__thread_8c_source.html#l00046">os_ip_t::lo8</a>, <a class="el" href="os__thread_8h_source.html#l00051">OS_CONTEXT_SIZE</a>, <a class="el" href="os__thread_8h_source.html#l00119">os_enterCS</a>, <a class="el" href="os__thread_8c_source.html#l00108">os_exitCS()</a>, <a class="el" href="os__thread_8c_source.html#l00053">os_kernel_stack</a>, <a class="el" href="os__thread_8h_source.html#l00049">OS_KERNEL_STACKSIZE</a>, <a class="el" href="os__thread_8c_source.html#l00241">os_mask_stack()</a>, <a class="el" href="os__thread_8h_source.html#l00048">OS_MAX_THREADS</a>, <a class="el" href="os__scheduler_8c_source.html#l00049">os_scheduling_allowed</a>, <a class="el" href="os__thread_8c_source.html#l00051">os_threads</a>, <a class="el" href="behaviour__drive__chess_8c_source.html#l00163">p</a>, <a class="el" href="os__thread_8h_source.html#l00084">Tcb_t::stack</a> und <a class="el" href="os__thread_8h_source.html#l00087">Tcb_t::wait_for</a>.</p>

<p><div class="dynheader">
Hier ist ein Graph der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="os__thread_8c_a2225be2eb34882c09ae7ad31a8b07207_cgraph.png" border="0" usemap="#os__thread_8c_a2225be2eb34882c09ae7ad31a8b07207_cgraph" alt=""/></div>
<map name="os__thread_8c_a2225be2eb34882c09ae7ad31a8b07207_cgraph" id="os__thread_8c_a2225be2eb34882c09ae7ad31a8b07207_cgraph">
<area shape="rect" id="node3" href="os__thread_8h.html#a146cd9b383b02d8e5424e2de5bfdf7e1" title="Beendet den kritischen Abschnitt wieder, der mit os_enterCS began." alt="" coords="199,55,281,83"/><area shape="rect" id="node15" href="os__thread_8c.html#ac0440fe078802d66f53552e2eaec35fb" title="os_mask_stack" alt="" coords="183,106,297,134"/><area shape="rect" id="node5" href="os__scheduler_8h.html#aaf0ea29568109bcdfb1d527f223accad" title="os_schedule" alt="" coords="347,55,445,83"/><area shape="rect" id="node7" href="fifo_8c.html#a7b3f9ad457273c9717bff49113c84250" title="fifo_put_data" alt="" coords="508,30,607,58"/><area shape="rect" id="node13" href="os__thread_8h.html#afa82438e9832609bc5ffbddad166e1b7" title="Schaltet &quot;von aussen&quot; auf einen neuen Thread um." alt="" coords="495,81,620,109"/><area shape="rect" id="node9" href="builtins_8h.html#a41590bd57be6a89c1b9bcafe523207f2" title="Disables all interrupts by clearing the global interrupt mask." alt="" coords="676,5,791,33"/><area shape="rect" id="node11" href="os__thread__pc_8c.html#aa0b166109be9754de9b8b863b8d197c7" title="os_signal_unlock" alt="" coords="671,55,796,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a146cd9b383b02d8e5424e2de5bfdf7e1"></a><!-- doxytag: member="os_thread.c::os_exitCS" ref="a146cd9b383b02d8e5424e2de5bfdf7e1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_exitCS </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Beendet den kritischen Abschnitt wieder, der mit os_enterCS began. </p>
<p>Beendet den kritischen Abschnitt wieder, der mit os_enterCS began. Falls ein Scheduler-Aufruf ansteht, wird er nun ausgefuehrt. </p>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00108">108</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Benutzt <a class="el" href="os__scheduler_8c_source.html#l00217">os_schedule()</a>, <a class="el" href="os__scheduler_8c_source.html#l00049">os_scheduling_allowed</a> und <a class="el" href="timer_8h_source.html#l00088">TIMER_GET_TICKCOUNT_32</a>.</p>

<p>Wird benutzt von <a class="el" href="botfs-low_8c_source.html#l00190">botfs_acquire_lock_low()</a>, <a class="el" href="command_8c_source.html#l00333">command_write()</a>, <a class="el" href="command_8c_source.html#l00387">command_write_data()</a>, <a class="el" href="command_8c_source.html#l00356">command_write_rawdata_to()</a>, <a class="el" href="command_8c_source.html#l00318">command_write_to()</a>, <a class="el" href="display_8c_source.html#l00231">display_flash_puts()</a>, <a class="el" href="mmc_8c_source.html#l00458">mmc_init()</a>, <a class="el" href="mmc_8c_source.html#l00209">mmc_read_sector_spi()</a>, <a class="el" href="mmc_8c_source.html#l00292">mmc_write_sector_spi()</a>, <a class="el" href="os__scheduler_8c_source.html#l00093">os_calc_utilization()</a>, <a class="el" href="os__scheduler_8c_source.html#l00129">os_clear_utilization()</a> und <a class="el" href="os__thread_8c_source.html#l00065">os_create_thread()</a>.</p>

<p><div class="dynheader">
Hier ist ein Graph der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="os__thread_8c_a146cd9b383b02d8e5424e2de5bfdf7e1_cgraph.png" border="0" usemap="#os__thread_8c_a146cd9b383b02d8e5424e2de5bfdf7e1_cgraph" alt=""/></div>
<map name="os__thread_8c_a146cd9b383b02d8e5424e2de5bfdf7e1_cgraph" id="os__thread_8c_a146cd9b383b02d8e5424e2de5bfdf7e1_cgraph">
<area shape="rect" id="node3" href="os__scheduler_8h.html#aaf0ea29568109bcdfb1d527f223accad" title="os_schedule" alt="" coords="139,55,237,83"/><area shape="rect" id="node5" href="fifo_8c.html#a7b3f9ad457273c9717bff49113c84250" title="fifo_put_data" alt="" coords="300,30,399,58"/><area shape="rect" id="node11" href="os__thread_8h.html#afa82438e9832609bc5ffbddad166e1b7" title="Schaltet &quot;von aussen&quot; auf einen neuen Thread um." alt="" coords="287,81,412,109"/><area shape="rect" id="node7" href="builtins_8h.html#a41590bd57be6a89c1b9bcafe523207f2" title="Disables all interrupts by clearing the global interrupt mask." alt="" coords="468,5,583,33"/><area shape="rect" id="node9" href="os__thread__pc_8c.html#aa0b166109be9754de9b8b863b8d197c7" title="os_signal_unlock" alt="" coords="463,55,588,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac0440fe078802d66f53552e2eaec35fb"></a><!-- doxytag: member="os_thread.c::os_mask_stack" ref="ac0440fe078802d66f53552e2eaec35fb" args="(void *stack, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_mask_stack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maskiert einen Stack, um spaeter ermitteln zu koennen, wieviel Byte ungenutzt bleiben </p>
<dl><dt><b>Parameter:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>Anfangsadresse des Stacks </td></tr>
    <tr><td class="paramname">size</td><td>Groesse des Stacks in Byte </td></tr>
  </table>
  </dd>
</dl>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00241">241</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Wird benutzt von <a class="el" href="init-low_8c_source.html#l00125">ctbot_init_low_1st()</a>, <a class="el" href="init-low_8c_source.html#l00155">ctbot_init_low_last()</a> und <a class="el" href="os__thread_8c_source.html#l00065">os_create_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="a03112bc663383c20072a345d7648e89c"></a><!-- doxytag: member="os_thread.c::os_print_stackusage" ref="a03112bc663383c20072a345d7648e89c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_print_stackusage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gibt per LOG aus, wieviel Bytes auf den Stacks der Threads noch nie benutzt wurden </p>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00265">265</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Benutzt <a class="el" href="log_8h_source.html#l00307">LOG_INFO</a>, <a class="el" href="map_8c_source.html#l00207">map_2_sim_worker_stack</a>, <a class="el" href="map_8c_source.html#l00171">map_update_stack</a>, <a class="el" href="os__scheduler_8c_source.html#l00051">os_idle_stack</a> und <a class="el" href="os__thread_8c_source.html#l00053">os_kernel_stack</a>.</p>

<p>Wird benutzt von <a class="el" href="os__scheduler_8c_source.html#l00274">os_display()</a>.</p>

</div>
</div>
<a class="anchor" id="aa62b6d29ae00ff288fd8969807a62b06"></a><!-- doxytag: member="os_thread.c::os_signal_set" ref="aa62b6d29ae00ff288fd8969807a62b06" args="(os_signal_t *signal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_signal_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structos__signal__t.html">os_signal_t</a> *&#160;</td>
          <td class="paramname"><em>signal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blockiert den aktuellen Thread, bis ein Signal freigegeben wird. </p>
<p>Blockiert den aktuellen Thread, bis ein Signal freigegeben wird </p>
<dl><dt><b>Parameter:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*signal</td><td>Zeiger auf Signal </td></tr>
  </table>
  </dd>
</dl>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00153">153</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Benutzt <a class="el" href="os__scheduler_8c_source.html#l00217">os_schedule()</a>, <a class="el" href="timer_8h_source.html#l00088">TIMER_GET_TICKCOUNT_32</a> und <a class="el" href="os__thread_8h_source.html#l00087">Tcb_t::wait_for</a>.</p>

<p><div class="dynheader">
Hier ist ein Graph der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="os__thread_8c_aa62b6d29ae00ff288fd8969807a62b06_cgraph.png" border="0" usemap="#os__thread_8c_aa62b6d29ae00ff288fd8969807a62b06_cgraph" alt=""/></div>
<map name="os__thread_8c_aa62b6d29ae00ff288fd8969807a62b06_cgraph" id="os__thread_8c_aa62b6d29ae00ff288fd8969807a62b06_cgraph">
<area shape="rect" id="node3" href="os__scheduler_8h.html#aaf0ea29568109bcdfb1d527f223accad" title="os_schedule" alt="" coords="160,55,259,83"/><area shape="rect" id="node5" href="fifo_8c.html#a7b3f9ad457273c9717bff49113c84250" title="fifo_put_data" alt="" coords="321,30,420,58"/><area shape="rect" id="node11" href="os__thread_8h.html#afa82438e9832609bc5ffbddad166e1b7" title="Schaltet &quot;von aussen&quot; auf einen neuen Thread um." alt="" coords="308,81,433,109"/><area shape="rect" id="node7" href="builtins_8h.html#a41590bd57be6a89c1b9bcafe523207f2" title="Disables all interrupts by clearing the global interrupt mask." alt="" coords="489,5,604,33"/><area shape="rect" id="node9" href="os__thread__pc_8c.html#aa0b166109be9754de9b8b863b8d197c7" title="os_signal_unlock" alt="" coords="484,55,609,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a772b2312a1edbfeeb3e41510b5e62ef9"></a><!-- doxytag: member="os_thread.c::os_stack_dump" ref="a772b2312a1edbfeeb3e41510b5e62ef9" args="(Tcb_t *thread, void *stack, uint16_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_stack_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTcb__t.html">Tcb_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gibt den Inhalt des Stacks eines Threads per LOG aus </p>
<dl><dt><b>Parameter:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*thread</td><td>Zeiger auf den TCB des Threads </td></tr>
    <tr><td class="paramname">*stack</td><td>Zeiger auf die hoechste Adresse des Stacks (Anfang) </td></tr>
    <tr><td class="paramname">size</td><td>Groesse des Stacks in Byte </td></tr>
  </table>
  </dd>
</dl>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00303">303</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Benutzt <a class="el" href="behaviour__drive__chess_8c_source.html#l00175">i</a>, <a class="el" href="log_8h_source.html#l00307">LOG_INFO</a>, <a class="el" href="behaviour__drive__chess_8c_source.html#l00161">n</a> und <a class="el" href="os__thread_8h_source.html#l00084">Tcb_t::stack</a>.</p>

<p>Wird benutzt von <a class="el" href="os__scheduler_8c_source.html#l00274">os_display()</a>.</p>

</div>
</div>
<a class="anchor" id="afa82438e9832609bc5ffbddad166e1b7"></a><!-- doxytag: member="os_thread.c::os_switch_thread" ref="afa82438e9832609bc5ffbddad166e1b7" args="(Tcb_t *from, Tcb_t *to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_switch_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTcb__t.html">Tcb_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTcb__t.html">Tcb_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schaltet "von aussen" auf einen neuen Thread um. </p>
<p>Schaltet "von aussen" auf einen neuen Thread um. =&gt; kernel threadswitch Achtung, es wird erwartet, dass Interrupts an sind. Sollte eigentlich nur vom Scheduler aus aufgerufen werden! </p>
<dl><dt><b>Parameter:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*from</td><td>Zeiger auf TCB des aktuell laufenden Threads </td></tr>
    <tr><td class="paramname">*to</td><td>Zeiger auf TCB des Threads, der nun laufen soll </td></tr>
  </table>
  </dd>
</dl>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00166">166</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Benutzt <a class="el" href="os__thread_8h_source.html#l00084">Tcb_t::stack</a>.</p>

<p>Wird benutzt von <a class="el" href="os__scheduler_8c_source.html#l00217">os_schedule()</a>.</p>

</div>
</div>
<a class="anchor" id="af29e431cbca02833132a67de16011925"></a><!-- doxytag: member="os_thread.c::os_thread_yield" ref="af29e431cbca02833132a67de16011925" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schaltet auf den Thread mit der naechst niedrigeren Prioritaet um, der lauffaehig ist, indem diesem der Rest der Zeitscheibe geschenkt wird. </p>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00119">119</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Benutzt <a class="el" href="os__thread_8h_source.html#l00086">Tcb_t::lastSchedule</a>, <a class="el" href="command_8c_source.html#l00071">LOG_DEBUG</a>, <a class="el" href="os__thread_8h_source.html#l00074">os_stat_data_t::missed_deadlines</a>, <a class="el" href="timer_8h_source.html#l00040">MS_TO_TICKS</a>, <a class="el" href="os__thread_8h_source.html#l00085">Tcb_t::nextSchedule</a>, <a class="el" href="os__thread_8h_source.html#l00119">os_enterCS</a>, <a class="el" href="os__scheduler_8c_source.html#l00217">os_schedule()</a>, <a class="el" href="os__scheduler_8c_source.html#l00049">os_scheduling_allowed</a>, <a class="el" href="os__scheduler_8h_source.html#l00034">OS_TIME_SLICE</a>, <a class="el" href="os__thread_8h_source.html#l00073">os_stat_data_t::runtime</a>, <a class="el" href="os__thread_8h_source.html#l00089">Tcb_t::statistics</a>, <a class="el" href="timer_8h_source.html#l00088">TIMER_GET_TICKCOUNT_32</a> und <a class="el" href="timer_8h_source.html#l00154">TIMER_STEPS</a>.</p>

<p><div class="dynheader">
Hier ist ein Graph der zeigt, was diese Funktion aufruft:</div>
<div class="dyncontent">
<div class="center"><img src="os__thread_8c_af29e431cbca02833132a67de16011925_cgraph.png" border="0" usemap="#os__thread_8c_af29e431cbca02833132a67de16011925_cgraph" alt=""/></div>
<map name="os__thread_8c_af29e431cbca02833132a67de16011925_cgraph" id="os__thread_8c_af29e431cbca02833132a67de16011925_cgraph">
<area shape="rect" id="node3" href="os__scheduler_8h.html#aaf0ea29568109bcdfb1d527f223accad" title="os_schedule" alt="" coords="173,55,272,83"/><area shape="rect" id="node5" href="fifo_8c.html#a7b3f9ad457273c9717bff49113c84250" title="fifo_put_data" alt="" coords="335,30,433,58"/><area shape="rect" id="node11" href="os__thread_8h.html#afa82438e9832609bc5ffbddad166e1b7" title="Schaltet &quot;von aussen&quot; auf einen neuen Thread um." alt="" coords="321,81,447,109"/><area shape="rect" id="node7" href="builtins_8h.html#a41590bd57be6a89c1b9bcafe523207f2" title="Disables all interrupts by clearing the global interrupt mask." alt="" coords="503,5,617,33"/><area shape="rect" id="node9" href="os__thread__pc_8c.html#aa0b166109be9754de9b8b863b8d197c7" title="os_signal_unlock" alt="" coords="497,55,623,83"/></map>
</div>
</p>

</div>
</div>
<hr/><h2>Variablen-Dokumentation</h2>
<a class="anchor" id="a106f72a08737e37e3b19428051f6b8f7"></a><!-- doxytag: member="os_thread.c::dummy_signal" ref="a106f72a08737e37e3b19428051f6b8f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structos__signal__t.html">os_signal_t</a> <a class="el" href="os__thread_8c.html#a106f72a08737e37e3b19428051f6b8f7">dummy_signal</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal, das referenziert wird, wenn sonst keins gesetzt ist. </p>
<p>Signal, das referenziert wird, wenn sonst keins gesetzt ist </p>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00054">54</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Wird benutzt von <a class="el" href="os__thread_8c_source.html#l00065">os_create_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="a684b331eb0a74daf505e2ae7e9f1bb64"></a><!-- doxytag: member="os_thread.c::os_kernel_stack" ref="a684b331eb0a74daf505e2ae7e9f1bb64" args="[OS_KERNEL_STACKSIZE]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="os__thread_8c.html#a684b331eb0a74daf505e2ae7e9f1bb64">os_kernel_stack</a>[OS_KERNEL_STACKSIZE]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Kernel-Stack. </p>
<p>Kernel-Stack </p>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00053">53</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

<p>Wird benutzt von <a class="el" href="timer-low_8c_source.html#l00052">ISR()</a>, <a class="el" href="os__thread_8c_source.html#l00065">os_create_thread()</a> und <a class="el" href="os__thread_8c_source.html#l00265">os_print_stackusage()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7c832fad63b24918265cadcd962e5ab"></a><!-- doxytag: member="os_thread.c::os_thread_running" ref="aa7c832fad63b24918265cadcd962e5ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTcb__t.html">Tcb_t</a>* <a class="el" href="os__thread__pc_8c.html#aa7c832fad63b24918265cadcd962e5ab">os_thread_running</a> = NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zeiger auf den Thread, der zurzeit laeuft. </p>
<p>Zeiger auf den TCB des Threads, der gerade laeuft </p>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00052">52</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

</div>
</div>
<a class="anchor" id="a98e9aac6030735e7a03aa7b3681c43a2"></a><!-- doxytag: member="os_thread.c::os_threads" ref="a98e9aac6030735e7a03aa7b3681c43a2" args="[OS_MAX_THREADS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTcb__t.html">Tcb_t</a> <a class="el" href="os__thread__pc_8c.html#a98e9aac6030735e7a03aa7b3681c43a2">os_threads</a>[OS_MAX_THREADS]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thread-Pool (ist gleichzeitig running- und waiting-queue) </p>
<p>Array aller TCBs </p>

<p>Definiert in Zeile <a class="el" href="os__thread_8c_source.html#l00051">51</a> der Datei <a class="el" href="os__thread_8c_source.html">os_thread.c</a>.</p>

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Erzeugt am Mit Feb 29 2012 14:18:12 für c't-Bot von &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
