<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head><title>RemoteCall - c't-Bot und c't-Sim - Trac</title>
<link type="text/css" href="trac.css" rel="stylesheet"/>
<link type="text/css" href="wiki.css" rel="stylesheet"/>
<link type="text/css" href="code.css" rel="stylesheet"/>
</head>
<body>

<div class="wikipage">
    <div id="searchable"><h2 id="FunktionsweisederRemote-Calls">Funktionsweise der Remote-Calls<a href="http://www.heise.de/ct/projekte/machmit/ctbot/wiki/RemoteCall#FunktionsweisederRemote-Calls" class="anchor" title="Link to this section"> ¶</a></h2>
<p>
Hier gibt es eine Erklärung, wie die <a href="http://www.heise.de/ct/projekte/machmit/ctbot/browser/devel/ct-Bot/bot-logic/behaviour_remotecall.c" class="source">Remote-Calls</a> <i>intern</i> funktionieren. Es geht also in erster Linie um die Implementierung inkl. einiger Details und nicht darum, wie man die Remote-Calls benutzt.
</p>
<p>
Stand: Version <a title="Kommentar-Bugfix" href="http://www.heise.de/ct/projekte/machmit/ctbot/changeset/1318" class="changeset">[1318]</a><br/><br/>
</p>
<h3 id="DerKern">Der Kern<a href="http://www.heise.de/ct/projekte/machmit/ctbot/wiki/RemoteCall#DerKern" class="anchor" title="Link to this section"> ¶</a></h3>
<p>
Die wesentliche Funktionalität der Remote-Calls ist als <a href="http://www.heise.de/ct/projekte/machmit/ctbot/browser/devel/ct-Bot/include/bot-logic/available_behaviours.h" class="source">Bot-Verhalten</a> implementiert, das mit der höchstens Priorität läuft und auf Anforderung andere Verhalten starten kann.<br/>
<br/>
</p>
<p>
Wir betrachten nun zunächst schrittweise die Implementierung dieses Verhaltens und damit den Kern der Remote-Calls, nämlich die Funktion <tt>void bot_remotecall_behaviour(Behaviour_t *data)</tt>:<br/>
</p>
<div class="code"><pre><b><span class="code-type">void</span></b> <b><span class="code-func">bot_remotecall_behaviour</span></b>(Behaviour_t *data) {
 LOG_DEBUG(<b><span class="code-string">"Enter bot_remotecall_behaviour"</span></b>);

 <b><span class="code-lang">switch</span></b> (running_behaviour) {
  <b><span class="code-lang">case</span></b> <b><span class="code-keyword">REMOTE_CALL_SCHEDULED</span></b>: <i><span class="code-comment">// Es laueft kein Auftrag, aber es steht ein neuer an
</span></i>   LOG_DEBUG(<b><span class="code-string">"REMOTE_CALL_SCHEDULED"</span></b>);
</pre></div><p>
Für den Fall, dass ein neuer Remote-Call ansteht, wird dieses Codestück ausgeführt. Zum jetzigen Zeitpunkt sind durch den vorherigen Aufruf der Botenfunktion <tt>bot_remotecall()</tt> bereits einige Variablen initialisiert worden:
</p>
<ul><li><tt>function_id</tt> enthält die Remote-Call-ID des zu startenden Verhaltens (im Folgenden <strong>X</strong> genannt).
</li><li><tt>parameter_count</tt> enthält die Anzahl der Parameter, die die Botenfunktion des Verhaltens X erwartet.
</li><li><tt>parameter_length</tt> ist ein Array, das für jeden Parameter dessen Größe in Byte enhält.
</li><li><tt>parameter_data</tt> ist ein Array, das die bereits korrekt formatierten Daten der Parameter für Verhalten X enthält.<br/>
</li></ul><p>
Der folgende Code speichert und prüft die Remote-Call-ID von X und lädt anschließend die Adresse der Botenfunktion von X in den Funktionszeiger <tt>func</tt>. Im Falle des realen Bots liegt Letztere im Flash, um RAM zu sparen.
</p>
<div class="code"><pre>   <b><span class="code-lang">if</span></b> (function_id >= STORED_CALLS) {
    LOG_DEBUG(<b><span class="code-string">"keine Funktion gefunden. Exit"</span></b>);
    running_behaviour=REMOTE_CALL_IDLE;
    <b><span class="code-lang">return</span></b>;
   }

   #ifdef PC
    <b><span class="code-type">void</span></b> (* func) (<b><span class="code-type">struct</span></b> _Behaviour_t * data, ...);
    <i><span class="code-comment">// Auf dem PC liegt die calls-Struktur im RAM
</span></i>    func = (<b><span class="code-type">void</span></b> *) calls[function_id].func;
   #<b><span class="code-lang">else</span></b> <i><span class="code-comment">// MCU
</span></i>    <b><span class="code-type">void</span></b> (* func) (<b><span class="code-type">struct</span></b> _Behaviour_t * data, remote_call_data_t dword1, 
     remote_call_data_t dword2);
    <i><span class="code-comment">// Auf dem MCU liegt die calls-Struktur im Flash und muss erst geholt werden
</span></i>    func = (<b><span class="code-type">void</span></b> *) pgm_read_word(&calls[function_id].func);
   #endif <i><span class="code-comment">// PC
</span></i>
</pre></div><p>
Für PC bekommt der Funktionszeiger eine variable Anzahl an Parametern, um auf Architekturen, die die Funktionsparameter nicht per Stack sondern in Registern übergeben, sowohl Integer- als auch Float-Parameter abzudecken (auf PPC werden die Parameter dann sowohl in die GP-Register als auch in die FP-Register kopiert - hierzu wird die Funktion <tt>bot_remotecall_fl_dummy</tt> aufgerufen).<br/>
Für MCU landen alle Parameter einer variablen Parameterliste auf dem Stack, unsere Botenfunktionen erwarten sie aber in Registern. Daher belegen wir hier acht Byte mit Parametern, "überschüssige" Parameter werden zwar in Register kopiert, von dort aber nie gelesen und stören deshalb auch nicht.
</p>
<p>
Nun gilt es drei Fälle zu unterscheiden:
</p>
<ul><li>a) Die Botenfunktion von X erwartet außer dem obligatorischen Zeiger <tt>*caller</tt> auf den Aufrufer keine Parameter. Der Zeiger des Aufrufers wird hier grundsätzlich nicht mitgezählt.
</li><li>b) Die Botenfunktion von X erwartet Parameter, aber maximal <tt>REMOTE_CALL_MAX_PARAM</tt> viele.
</li><li>c) Die Botenfunktion von X erwartet mehr Parameter, als von den Remote-Calls unterstützt werden.
</li></ul><p>
Im Fall c) passiert nichts, da wir die Parameter nicht korrekt übergeben können:
</p>
<div class="code"><pre>   <b><span class="code-lang">if</span></b> (parameter_count > REMOTE_CALL_MAX_PARAM) {
    LOG_DEBUG(<b><span class="code-string">"Parameteranzahl unzulaessig!"</span></b>);
    running_behaviour=REMOTE_CALL_IDLE;
    <b><span class="code-lang">return</span></b>;
   }
</pre></div><p>
Der Fall a) ist sehr einfach, wird im Code aber nicht extra behandelt, s.u.
</p>
<p>
Interessant wird es nun im Fall b). Vorweg ein paar Worte, was hier grundsätzlich zu tun ist:<br/>
</p>
<p>
Die Parameterdaten stehen im Array <tt>parameter_data</tt> und <tt>func</tt> zeigt auf die Botenfunktion. Wenn wir den Typ der Parameter einfach mal außer Acht lassen, müssen wir jetzt folgendes tun:<br/>
</p>
<div class="code"><pre><b><span class="code-func">func</span></b>(data, parameter_data[0], ..., parameter_data[3]);
running_behaviour = REMOTE_CALL_RUNNING;
<b><span class="code-lang">return</span></b>;
</pre></div><p>
Also die Botenfunktion mit der Anzahl der zugehörigen Parameter aufrufen und anschließend auf den Status <tt>REMOTE_CALL_RUNNING</tt> umschalten.<br/>
</p>
<p>
Das Problem ist hier nur, dass die Paramter unterschiedlich groß und unter Umständen größer als die Maschinenwortbreite der Zielarchtitektur sein können. Es reicht also nicht, je nach Anzahl der Parameter einen Funktionszeiger mit n Parametern anzulegen und diesen aufzurufen. <br/>
Stattdessen kommt hier der oben bereits kurz genannte Trick zum Einsatz: Wir übergeben dem Funktionszeiger einfach soviel Parameter, wie es maximal geben kann. Sind das mehr, als für das eigentliche Verhalten nötig, liegen diese zwar auf dem Stack oder in Registern, stören dort aber auch nicht weiter. <br/>
Für PC ist der Fall sehr einfach, da die maximale Parameterbreite kleinergleich der Maschninenwortbreite und somit der Register- oder Stackbreite ist. Ein uint8_t Parameter belegt auf einer 32 Bit Architektur z.B. immer 4 Byte auf dem Stack bzw. ein ganzes 32 Bit Register. Hier haben wir also genau das Format, in dem die Parameter auch vom Sim kommen.<br/>
Für MCU ist es etwas komplizierter, hier werden alle Parameter in 8 Bit-Registern übergeben, aber 16 Bit aligned:<br/>
</p>
<ol><li>Die Größe in Byte wird zur nächsten geraden Zahl aufgerundet, falls sie ungerade ist. 
</li><li>Der Registerort fängt mit 26 an.
</li><li>Vom Registerort wird die berechete Größe abgezogen und das Argument in diesen Registern übergeben (LSB first).<br/>
</li></ol><p>
Diese Konvertierung erledigt die Funktion <tt>remotecall_convert_params</tt>.<br/>
</p>
<p>
Der folgende Code führt nun zum gewünschten Ergebnis:
</p>
<div class="code"><pre>   LOG_DEBUG(<b><span class="code-string">"function_id=%u"</span></b>, function_id);
   LOG_DEBUG(<b><span class="code-string">"parameter_count=%u"</span></b>, parameter_count);
   #ifdef PC
    bot_remotecall_fl_dummy(data, (*(remote_call_data_t*)parameter_data).fl32, 
     (*(remote_call_data_t*)(parameter_data+4)).fl32,
     (*(remote_call_data_t*)(parameter_data+8)).fl32);
    func(data, *(remote_call_data_t*)parameter_data,
     *(remote_call_data_t*)(parameter_data+4),
     *(remote_call_data_t*)(parameter_data+8));
   #<b><span class="code-lang">else</span></b> <i><span class="code-comment">// MCU
</span></i>    func(data, *(remote_call_data_t*)(parameter_data+4),
     *(remote_call_data_t*)parameter_data);                             
   #endif <i><span class="code-comment">// PC
</span></i>
</pre></div><p>
Die Dummy-Funktion ist nur für die PowerPC-Architektur wichtig (s.o.), der eigentliche Funktionsaufruf im PC-Fall entspricht dem ersten Ansatz. 
Für MCU bleibt lediglich noch zu beachten, dass die Parameterdaten hier in umgekehrter Reihenfolge übergeben werden müssen, weil mit aufsteigenden Parametern absteigende Register verwendet werden (s.o.). <br/>
</p>
<p>
Anschließend aktualisieren wir noch den Status und verlassen die Verhaltens-Funktion:
</p>
<div class="code"><pre>   running_behaviour=REMOTE_CALL_RUNNING;
   <b><span class="code-lang">return</span></b>;
</pre></div><p>
Ist das aufgerufene Verhalten fertig, wird wieder das Remote-Call-Verhalten aktiv und erledigt mit folgendem Code den Rest:
</p>
<div class="code"><pre>  <b><span class="code-lang">case</span></b> <b><span class="code-keyword">REMOTE_CALL_RUNNING</span></b>: <i><span class="code-comment">// Es lief ein Verhalten und ist nun zuende
</span></i>  {
   <i><span class="code-comment">// Antwort schicken
</span></i>   <b><span class="code-type">char</span></b> * function_name;
   #ifdef PC
    function_name=(<b><span class="code-type">char</span></b>*)&calls[function_id].name;
   #<b><span class="code-lang">else</span></b>
    <i><span class="code-comment">// Auf dem MCU muessen wir die Daten erstmal aus dem Flash holen
</span></i>    <b><span class="code-type">char</span></b> tmp[REMOTE_CALL_FUNCTION_NAME_LEN+1];
    memcpy_P(tmp, &calls[function_id].name, REMOTE_CALL_FUNCTION_NAME_LEN+1);
    function_name=(<b><span class="code-type">char</span></b>*)&tmp;
   #endif <i><span class="code-comment">// PC 
</span></i>    
   #ifdef COMMAND_AVAILABLE
    int16 result = data->subResult;
    command_write_data(CMD_REMOTE_CALL,SUB_REMOTE_CALL_DONE,&result,&result,function_name);
    LOG_DEBUG(<b><span class="code-string">"Remote-call %s beendet (%d)"</span></b>,function_name,result);
   #endif
                
   <i><span class="code-comment">// Aufrauemen
</span></i>   function_id=255;
   running_behaviour=REMOTE_CALL_IDLE;
   return_from_behaviour(data); <i><span class="code-comment">// und Verhalten auch aus
</span></i>   <b><span class="code-lang">break</span></b>;
  }
  <b><span class="code-keyword">default</span></b>:
   return_from_behaviour(data); <i><span class="code-comment">// und Verhalten auch aus
</span></i>   <b><span class="code-lang">break</span></b>;
 }
}
</pre></div><p>
Das beschränkt sich auf bekannte Funktionen: Daten aus dem Flash laden, Ergebnis über die Command-Schnittstelle an den Sim senden und den eigenen Status aktualisieren. Daraufhin können wir das Verhalten verlassen.<br/>
</p>
<h3 id="Hilfsfunktionen">Hilfsfunktionen<a href="http://www.heise.de/ct/projekte/machmit/ctbot/wiki/RemoteCall#Hilfsfunktionen" class="anchor" title="Link to this section"> ¶</a></h3>
<p>
Um die vom c't-Sim übergebenen Parameter für die verschiedenen Zielarchitekturen korrekt aufzubereiten, gibt es die Hilfsfunktion <strong><tt>remotecall_convert_params</tt></strong>.<br/>
Falls die Zielarchitektur ein x86-System ist, gibt es für <tt>remotecall_convert_params</tt> nicht viel zu tun, die Daten werden einfach 1 zu 1 in den Zielpuffer kopiert (Datenformat <i>Little-Endian</i>, <i>32-Bit alignment</i> - genau so kommen die Daten vom c't-Sim über die Leitung).<br/>
Für die AVR-Architektur sieht das Ganze etwas umfangreicher aus:
</p>
<div class="code"><pre><b><span class="code-type">static</span></b> <b><span class="code-type">void</span></b> <b><span class="code-func">remotecall_convert_params</span></b>(uint8_t * dest, uint8_t count, uint8_t * len, 
 uint8_t * data) {
#<b><span class="code-keyword">ifdef</span></b> <span class="code-prep">MCU</span>
 dest += 8; <i><span class="code-comment">// ans Ende springen
</span></i>
</pre></div><ul><li><tt>dest</tt> ist ein Zeiger auf den Zielpuffer, der anschließend die konvertierten Daten enthalten wird.
</li><li><tt>count</tt> gibt die Anzahl der im Datenstrom enthaltenen Parameter an.
</li><li><tt>len</tt> ist ein Zeiger auf ein Array, das für jeden Parameter dessen Größe in Byte enthält.
</li><li><tt>data</tt> ist ein Zeiger auf den Quelldatenstrom.
</li></ul><p>
Da wir die Parameter rückwärts in den Puffer schreiben (Grund ist die Registerzuordnung des gcc auf der AVR-Architektur), lassen wir <tt>dest</tt> zunächst auf den letzten Eintrag zeigen.
</p>
<div class="code"><pre> uint8_t i;
 <i><span class="code-comment">/* Parameter rueckwaerts einlesen */</span></i>
 <b><span class="code-lang">for</span></b> (i=0; i<count; i++) {
  uint8_t pos = len[i] > 1 ? len[i] : 2; <i><span class="code-comment">// alle Parameter sind 16-Bit-aligned
</span></i>  dest -= pos;
  memcpy(dest, data, len[i]);
  data += <b><span class="code-lang">sizeof</span></b>(remote_call_data_t);
 }
</pre></div><p>
Hier geschieht nun das eigentliche Konvertieren. Pro Parameter wird in der for-Schleife als erstes dessen Länge ermittelt. Für den Fall, dass es sich um einen 8-Bit-Datentyp handelt, nehmen wir trotzdem 2 Byte an, wie es uns die ABI vorschreibt. 24 Bit-Datentypen werden nicht unterstützt.<br/>
Der Zielpuffer wird um die Länge des Parameters runtergezählt, anschließend werden die zum Parameter gehörenden Daten per <tt>memcpy()</tt> einfach kopiert. <br/>
Der Zeiger auf den Quelldatenstrom wird immer um 4 Byte erhöht, denn die Daten kommen ungepackt (32-Bit alignment) vom Sim.<br/>
</p>
<p>
Wie bereits erwähnt, gibt es im Fall einer Little-Endian-PC-Architektur nicht viel zu tun:
</p>
<div class="code"><pre>#<b><span class="code-keyword">else</span></b> // <span class="code-prep">PC</span>
#<b><span class="code-keyword">if</span></b> <span class="code-prep">BYTE_ORDER</span> == <span class="code-prep">LITTLE_ENDIAN</span>
 <i><span class="code-comment">/* Daten einfach kopieren */</span></i>
 memcpy(dest, data, count*<b><span class="code-lang">sizeof</span></b>(remote_call_data_t));
</pre></div><p>
Für den Fall, dass wir ein Big-Endian-System haben, müssen wir sämtliche Parameter "umdrehen", da die 32 Bit große Struktur <tt>remote_call_data_t</tt> hier genau entgegengesetzt im Speicher liegt:
</p>
<div class="code"><pre>#<b><span class="code-keyword">else</span></b> // <span class="code-prep">BIG_EDIAN</span>
 uint8_t i;
 <b><span class="code-lang">for</span></b> (i=0; i<count; i++) {
  <i><span class="code-comment">/* Parameter i von little-endian nach big-endian konvertieren*/</span></i>
  remote_call_data_t in, out;
  in = *((remote_call_data_t *)data);
  out.u32 = ((in.u32 & 0xff) << 24) | ((in.u32 & 0xff00) << 8) | 
   ((in.u32 & 0xff0000) >> 8) | ((in.u32 & 0xff000000) >> 24);
  memcpy(dest, &out, <b><span class="code-lang">sizeof</span></b>(remote_call_data_t));
  dest += <b><span class="code-lang">sizeof</span></b>(remote_call_data_t);
  data += <b><span class="code-lang">sizeof</span></b>(remote_call_data_t);
 }
#<b><span class="code-keyword">endif</span></b> // <span class="code-prep">LITTLE_EDIAN</span>
#<b><span class="code-keyword">endif</span></b> // <span class="code-prep">MCU</span>
</pre></div><p>
<br/>
</p>
<p>
Eine zweite Hilfsfunktion ist <strong><tt>getRemoteCall</tt></strong>, die in der Remote-Call-Tabelle nach einem Funktionsnamen sucht und die zugehörige ID zurückliefert:
</p>
<div class="code"><pre><b><span class="code-type">static</span></b> uint8 <b><span class="code-func">getRemoteCall</span></b>(<b><span class="code-type">char</span></b> * call) {
 LOG_DEBUG(<b><span class="code-string">"Suche nach Funktion: %s"</span></b>,call);
 uint8 i;
 <b><span class="code-lang">for</span></b> (i=0; i< (STORED_CALLS); i++) {
  <b><span class="code-lang">if</span></b> (!strcmp_P (call, calls[i].name)) {
   LOG_DEBUG(<b><span class="code-string">"calls[%d].name=%s passt"</span></b>,i,call);
   <b><span class="code-lang">return</span></b> i;
  }
 }
 <b><span class="code-lang">return</span></b> 255;
}
</pre></div><p>
Auf dem echten Bot liegen diese Daten im Flash-Speicher, die Funktion <tt>strcmp_P</tt> berücksichtigt das. Im PC-Fall wird sie per #define einfach durch <tt>strcmp</tt> ersetzt.
</p>
<h3 id="Botenfunktion">Botenfunktion<a href="http://www.heise.de/ct/projekte/machmit/ctbot/wiki/RemoteCall#Botenfunktion" class="anchor" title="Link to this section"> ¶</a></h3>
<p>
Zum Starten eines Remote-Calls wird wie bei allen Verhalten die <i>Botenfunktion</i> aufgerufen. Sie bekommt den Namen des zu startenden Verhaltens und die Parameterdaten als Zeiger übergeben:
</p>
<div class="code"><pre><b><span class="code-type">void</span></b> <b><span class="code-func">bot_remotecall</span></b>(Behaviour_t * caller, <b><span class="code-type">char</span></b> * func, remote_call_data_t * data) {
</pre></div><p>
Zunächst wird überprüft, ob das gewünschte Verhalten in der Remote-Call-Tabelle existiert und seine ID ermittelt:
</p>
<div class="code"><pre> function_id = getRemoteCall(func);
 <b><span class="code-lang">if</span></b> (function_id >= STORED_CALLS){
  LOG_ERROR(<b><span class="code-string">"Funktion %s nicht gefunden. Exit!"</span></b>, func);
  <b><span class="code-lang">return</span></b>;
 }
</pre></div><p>
Nun können wir das Verhalten aktivieren und müssen nur noch die restlichen der anfangs erwähnten Voraussetzungen schaffen, also die Parameterdaten holen und konvertieren:
</p>
<div class="code"><pre> switch_to_behaviour(caller, bot_remotecall_behaviour, NOOVERRIDE);
 #ifdef PC
  parameter_count = calls[function_id].param_count;
  parameter_length = (uint8*)calls[function_id].param_len;      
 #<b><span class="code-lang">else</span></b>
  <i><span class="code-comment">// Auf dem MCU muessen wir die Daten erstmal aus dem Flash holen
</span></i>  parameter_count = pgm_read_byte(&calls[function_id].param_count);
  memcpy_P(parameter_length, &calls[function_id].param_len, parameter_count);   
 #endif <i><span class="code-comment">// PC
</span></i> 
<b><span class="code-func">remotecall_convert_params</span></b>(parameter_data, parameter_count, parameter_length, (uint8*)data);
</pre></div><p>
Abschließend aktualisieren wir lediglich noch den internen Status und lassen das Verhalten arbeiten: :-)
</p>
<div class="code"><pre> running_behaviour = REMOTE_CALL_SCHEDULED;
}
</pre></div><p>
<br/>
</p>
<p>
<i>-- Ende --</i>
</p>
</div>
   </div>

</body>
</html>