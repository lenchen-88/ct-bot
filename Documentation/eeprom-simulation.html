<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.2  (Win32)">
	<META NAME="AUTHOR" CONTENT="Achim Pankalla">
	<META NAME="CREATED" CONTENT="20060528;19455600">
	<META NAME="CHANGEDBY" CONTENT="Achim Pankalla">
	<META NAME="CHANGED" CONTENT="20070617;18142584">
	<STYLE TYPE="text/css">
	<!--
		@page { size: 21cm 29.7cm; margin: 2cm }
		P { margin-bottom: 0.21cm }
	-->
	</STYLE>
</HEAD>
<BODY LANG="de-DE" DIR="LTR">
<P ALIGN=CENTER STYLE="margin-bottom: 0cm"><B>EEPROM Simulation f&uuml;r
PC</B></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><FONT SIZE=3><B>Author: </B></FONT>
</P>
<P STYLE="margin-bottom: 0cm"><FONT SIZE=3>Achim Pankalla
(achim.pankalla@gmx.de)</FONT></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><B>Beschreibung:</B></P>
<P ALIGN=LEFT STYLE="margin-bottom: 0cm; font-style: normal">Die
EEPROM Simulation f&uuml;r den PC stellt das EEPROM des <I>Atmel
MEGA32(644) Prozessor</I> auch dem Simulierten ct-Bot zur Verf&uuml;gung.
Der Zugriff auf dieses EEPROM erfolgt &uuml;ber gleichnamige
Funktionen, wie sie auch die avr-libc bereitstellt und auch die
Variablendefinition erfolgt &uuml;ber die gleichen Konstrukte. Eine
Unterscheidung &uuml;ber #ifdef's ist also nicht notwendig.<BR>Durch
diese EEPROM-Simulation, ist der Simulator dem realen Bot einen Schritt
n&auml;her gekommen und Programme mit EEPROM-Zugriffe k&ouml;nnen mit
der Simulation getestet werden. Mehr noch, sie k&ouml;nnen auch das
simulierte EEPROM auf den ct-Bot &uuml;bertragen oder das EEPROM vom
ct-Bot laden und f&uuml;r die Simulation nutzen.</P>
<P ALIGN=LEFT STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm; font-style: normal"><B>Implementierung:</B></P>
<P STYLE="margin-bottom: 0cm">Alle Funktionen und Einstellungen der
EEPROM Simulation findet Sie in den Dateien <I>pc/eeprom-emu_pc.c</I>
und <I>include/eeprom-emu.h</I>. Das EEPROM selbst wird durch eine
bin&auml;re Datei (genau 1 KB bzw. 2 KB gro&szlig;) repr&auml;sentiert (und
kann so mit einen HexEditor bearbeitet werden), deren Pfad in der
C-Datei festgelegt wird. Standard Pfad ist das Heimatverzeichnis des
ct-Bots. Nat&uuml;rlich k&ouml;nnen Sie das jederzeit &auml;ndern,
dies geht &uuml;ber die Konstante <FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2>EEPROM_FILENAME.</FONT></FONT></FONT>
<FONT FACE="Times New Roman, serif">Der Name </FONT><FONT FACE="Times New Roman, serif"><I>eeprom.bin</I></FONT>
<FONT FACE="Times New Roman, serif">sollte dabei belassen werden.</FONT><BR>Die
Datei wird automatisch neu angelegt, wenn sie noch nicht existiert.
Dann besteht der Inhalt nur aus 0xFF, wie es auch beim
unintialisierten EEPROM des Atmel der Fall ist.<BR>Damit die
EEPROM-Funktionen des PC korrekt auf die Datei zugreifen k&ouml;nnen
und nur ein Adressraum von 0 bis 1023 (2047) entsteht, bedarf es bei
der PC Implementierung (mit PC ist allgemein der Code f&uuml;r die
Simulation gemeint, mag das OS nun Win, Linux oder Mac OS X hei&szlig;en)
eines Tricks. Die Emulation muss wissen welche Speicheradresse die
erste Variable hat.<BR>Daf&uuml;r gibt es die beiden Variablen
<I>_eeprom_start1__</I> und <I>_eeprom_start2_</I><SPAN STYLE="font-style: normal">_
in </SPAN><I>1st_init.S</I><SPAN STYLE="font-style: normal">. Diese
stehen dort, damit sie auf jeden Fall vor der ersten EEPROM Variable
definiert werden und damit ihre Sections (.</SPAN><I>s1eeprom</I> <SPAN STYLE="font-style: normal">+
.</SPAN><I>s2eeprom</I><SPAN STYLE="font-style: normal">) auf jeden
Fall vor der Section .</SPAN><I>eeprom</I> <SPAN STYLE="font-style: normal">liegen.</P>
<P STYLE="margin-bottom: 0cm; font-style: normal">Durch diesen Trick
kann die Speicheradresse der ersten EEPROM Variable auch ohne
Linkerscript ermittelt werden und auch verschiedene
Section-Alignments (im Moment bei MinGW und Linux unterschiedlich)
haben keine Auswirkung.</P>
<P STYLE="margin-bottom: 0cm; font-style: normal">Auch beim
Generieren einer neuen Datei ct-Bot.exe/elf wird eine EEP mit den
Initialisierungen der EEPROM-Variablen im post-build angelegt. Diese
Datei kann die EEPROM-Simulation auch als Initialisierung f&uuml;r
ihr MCU-kompatibles EEPROM benutzen oder diese Datei kann direkt als
EEPROM-Datei benutzt werden, wenn die Simulation im PC-Modus ist,
gleiches gilt nat&uuml;rlich umgekehrt auch f&uuml;r die EEP Datei des
MCU.</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><B>Nutzung der EEPROM Simulation</B>.</P>
<P STYLE="margin-bottom: 0cm">Die EEPROM-Simulation unterscheidet
sich nur in ein paar Details von den Funktionen der avr-libc f&uuml;r den realen ct-Bot. 
Nat&uuml;rlich hat der PC kein EEPROM, dieses wird durch
eine Datei im Bin&auml;rformat emuliert. Der Dateinamen und der Pfad
wird &uuml;ber die Konstante EEPROM_FILENAME in <I>eeprom</I>-<I>emu</I>_<I>pc</I>.<I>c</I>
festgelegt. Ein weiterer Unterschied ist, dass beim avr-gcc &uuml;ber
ein DEFINE der Prozessortyp festgelegt wird, entweder ATMega32 oder
ATMega644. Dieses DEFINE ist beim PC Compiler normalerweise nicht
gesetzt. Standardm&auml;&szlig;ig wird von einem ATMega32 mit
1024 Byte EEPROM ausgegangen, Die Simulation kennt aber die Konstante
f&uuml;r den ATMega644 und erh&ouml;ht den EEPROM Speicher auf 2048
Bytes. Sollte schon eine 1 KB Datei f&uuml;rs EEPROM bestehen, so muss
diese gel&ouml;scht werden, damit die Gr&ouml;&szlig;ere angelegt
wird. Wird direkt die erstellte <I>ct-bot.eep</I> Datei genutzt, ist
dies nat&uuml;rlich nicht notwendig.</P>
<P STYLE="margin-bottom: 0cm">Alle wichtigen Informationen werden
beim Start von ct-Bot.exe/elf im Log-Fenster angezeigt, dort sieht man
auch alle eventuellen Fehler und ob die Simulation ordnungsgem&auml;&szlig;
arbeiten kann. Es erfolgt kein Beenden bei
Problemen, die Funktion des EEPROMs ist dann aber nicht gegeben.</P>
<P STYLE="margin-bottom: 0cm">Generell unterscheidet die Simulation
zwei Modi:</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm">PC-Modus</P>
	<P STYLE="margin-bottom: 0cm">In diesen Modus entspricht die
	eeprom.bin nicht dem EEPROM des realen ct-Bots und darf deshalb auch
	nicht auf ihn aufgespielt werden. Dieser Modus wird ohne jedes Zutun erreicht. 
	Er ben&ouml;tigt keine weiteren Eintr&auml;ge im Post-Build. 
	</P>
	<P STYLE="margin-bottom: 0cm">Wenn eine ct-bot.eep im Bin&auml;rformat erstellt wird,
	so kann diese direkt benutzt werden.</P>
	<LI><P STYLE="margin-bottom: 0cm">MCU-Modus</P>
	<P STYLE="margin-bottom: 0cm">Ist dieser Modus erreicht, kann man
	als EEPROM-Datei einen EEPROM Abzug vom ct-Bot verwenden.
	Voraussetzung ist nat&uuml;rlich, dass der Bot auch mit zuletzt
	erstelltem Programm bespielt ist. Nat&uuml;lich kann man auch die
	EEPROM-Datei auf dem Bot nutzen.<BR>Der MCU-Modus kann nur erreicht
	werden, wenn sowohl beim avr-ggc als auch unter der PC Oberfl&auml;che
	eine map-Datei erstellt werden, daf&uuml;r sind im Post-Build die
	folgenden Befehle einzutragen:</P>
	<P STYLE="margin-bottom: 0cm">Debug-W32: <B>objcopy -j .eeprom
	--change-section-lma .eeprom=0 -O binary ct-Bot.exe
	ct-Bot.eep;objdump -t ct-bot.exe | grep &quot;(sec&nbsp;&nbsp;5)&quot; | grep
	&quot;(nx 0)&quot; &gt; eeprom_pc.map</B></P>
	<P STYLE="margin-bottom: 0cm">Debug-MCU-W32: <B>avr-objcopy -O ihex
	-R .eeprom ct-Bot.elf ct-Bot.hex; avr-objcopy -j .eeprom
	--set-section-flags=.eeprom=&quot;alloc,load&quot;
	--change-section-lma .eeprom=0 -O binary ct-Bot.elf
	ct-Bot.eep;avr-objdump -t ct-bot.elf | grep &quot;O \.eeprom&quot; &gt;
	eeprom_mcu.map</B></P>
	<P STYLE="margin-bottom: 0cm"><B>(Achtung! Zwischen sec und 5 zwei
	Spaces)</B></P>
	<P STYLE="margin-bottom: 0cm">F&uuml;r Linux oder Mac OS X gelten &auml;hnliche Befehle, in den 
	Projekteinstellungen im SVN sind die n&ouml;tigen Post-Build-Einstellungen f&uuml;r alle
	Betriebssysteme bereits gemacht.
	</P>
	<P STYLE="margin-bottom: 0cm">Anhand dieser MAP-Datei k&ouml;nnen
	die Routinen des EEPROM-Managers &uuml;ber eine
	Konvertierungsfunktion die eeprom-Datei bot-kompatibel halten.
	Nat&uuml;rlich kann man trotzdem dieses EEPROM mit der EEP-Datei
	initialisieren.</P>
</OL>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm">M&ouml;chte man die vorhandene oder
noch nicht vorhandene EEPROM-Datei mit den Daten aus der EEP-Datei
initialisieren, so muss man die ct-Bot.exe/elf mit dem Parameter <I>-i
</I>starten, dabei spielt es keine Rolle in welchen Modus die
Emulation arbeitet. Der Pfad der EEP-Datei wird in der Konstante
<FONT COLOR="#000000"><FONT FACE="Courier New, monospace"><FONT SIZE=2>EEP_PC
</FONT></FONT></FONT><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>eingetragen.</FONT></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm"><FONT COLOR="#000000"><FONT FACE="Times New Roman, serif"><FONT SIZE=3>F&uuml;r
das Debuggen von Zugriffen auf das EEPROM stehen unter anderem die
DEFINES LOG_STORE und LOG_LOAD zur Verf&uuml;gung, die im MCU Modus
sogar den Variablennamen anzeigen. Andere Variationen sind auch noch
denkbar.</FONT></FONT></FONT></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm; font-style: normal"><B>Grenzen der
Implementierung</B></P>
<P STYLE="margin-bottom: 0cm; font-style: normal; font-weight: medium">
Im Moment erstellen gleiche Compilerversionen (zu &uuml;berpr&uuml;fen
mit --version) auch (fast) gleiche EEPROM-Sections. Damit es
auch mit verschiedenen Compiler Version geht (und ich mich auch nicht
auf die gleichen Versionen verlasssen will) habe ich die
Adresskonvertierung eingef&uuml;hrt, damit dies kein Problem mehr
ist.</P>
<P STYLE="margin-bottom: 0cm; font-style: normal; font-weight: medium">
Es gibt aber keine Garantien daf&uuml;r, dass zuk&uuml;nftige Compiler
Versionen nicht die Reihenfolge der Variablen im Code &auml;ndern.
Ein Einf&uuml;gen neuer EEPROM Variablen kann auch zu Verschiebungen
der Adressen f&uuml;hren. Nach solchen &Auml;nderungen ist man nur
auf der sicheren Seite, wenn das EEPROM initialisiert wird (sprich
Sie Ihre alte eeprom.bin bzw. auf dem Atmel das EEPROM l&ouml;schen).
Einmal erstellte Werte sind dann nat&uuml;rlich futsch. Wenn man den
Einfluss von Codeerg&auml;nzungen kontrollieren will, kann man dies
vor und nach der &Auml;nderung mit objdump machen (oder falls Sie
die Befehle f&uuml;r die MAP-Dateien im Post-Build benutzen, schauen
Sie in die MAP-Dateien), mit den richtigen Parametern kann man sich
die Adressverteilung anzeigen lassen. Sie k&ouml;nnen dann sehen, ob
die neuen Variablen nun hinten angeh&auml;ngt wurden (dann brauch das
EEPROM nicht gel&ouml;scht werden) oder sie dazwischen gelandet sind
(dann sind die alten Daten unbrauchbar), daf&uuml;r sollten sie aber
vorher in Eclipse Projekt-&gt;clean aufrufen.<BR>Die Implementierung
des EEPROM auf den PC kontrolliert nicht, ob 1 KB bzw. 2 KB an
Daten &uuml;berschritten wurden. Der EEPROM-Manager meckert dann aber
im LOG. (Der avr-gcc wird dann auch meckern). 
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><B>Funktionen</B></P>
<P STYLE="margin-bottom: 0cm"><B>Nur in eeprom-emu_pc.c sichtbare
Funktionen</B></P>
<P STYLE="margin-bottom: 0cm">store_parameter() - Speichern von
Informationen im simulierten EEPROM</P>
<P STYLE="margin-bottom: 0cm">load_parameter() - Laden von
Informationen aus dem simulierten EEPROM</P>
<P STYLE="margin-bottom: 0cm">init_eeprom() - Erstellt
Adresskonvertierungstabelle</P>
<P STYLE="margin-bottom: 0cm">conv_eeaddr() - Wandelt PC Adresse in
ct-Bot Adresse</P>
<P STYLE="margin-bottom: 0cm">create_ctab() - Erstellt
Adresskonvertierungstabelle</P>
<P STYLE="margin-bottom: 0cm">check_eeprom_file() - Erstellt leeres
EEPROM, wenn n&ouml;tig und initialisiert es, wenn gew&uuml;nscht</P>
<P STYLE="margin-bottom: 0cm">init_eeprom_man() - Initialisiert die
EEPROM Emulation</P>
<P STYLE="margin-bottom: 0cm"><B>Zugriffsfunktionen f&uuml;r den PC
(identisch zu denen der avr-libc)</B></P>
<P STYLE="margin-bottom: 0cm">eeprom_read_byte()</P>
<P STYLE="margin-bottom: 0cm">eeprom_write_byte()</P>
<P STYLE="margin-bottom: 0cm">eeprom_read_word()</P>
<P STYLE="margin-bottom: 0cm">eeprom_write_word()</P>
<P STYLE="margin-bottom: 0cm">eeprom_write_block()</P>
<P STYLE="margin-bottom: 0cm">eeprom_read_block()</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><FONT SIZE=3><B>Dateien:</B></FONT></P>
<P STYLE="margin-bottom: 0cm"><FONT SIZE=3>eeprom-emu.h - Headerdatei mit den Deklarationen</FONT></P>
<P STYLE="margin-bottom: 0cm"><FONT SIZE=3>eeprom-emu_pc.c - Implementierung der Funktionen
f&uuml;r ct-Bot &amp; ct-Sim</FONT></P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
</BODY>
</HTML>