<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="description" content="Uebersicht der Motorregelung des c't-Bots" />
<meta name="author" content="Timo Sandmann" />
<meta name="keywords" content="c't-Bot,speedcontrol,Motorregelung,pid" />
<meta name="date" content="2007-04-04" />
<title>c't-Bot - Motorregelung</title>
<link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
<h1>Dokumentation zur Motorregelung</h1>
<br />

<a class="menu" href="#uebersicht">Eine allgemeine &Uuml;bersicht</a><br />
<a class="menu" href="#details">Die Motorregelung im Detail</a>
<ul>
    <li><a class="menu" href="#params">Die Parameter</a></li>
    <li><a class="menu" href="#pid">Die eigentliche Regelung</a></li>
    <li><a class="menu" href="#sensor">Die Sensorauswertung</a></li>
    <li><a class="menu" href="#adjust">Finden und Einstellen der richtigen Parameter</a></li>
    <li><a class="menu" href="#log">Die Logging-Funktion</a></li>
</ul>

<a name="uebersicht"></a><h2>Eine allgemeine &Uuml;bersicht</h2>
<p>Die Ansteuerung der Motoren funktioniert wie folgt:<br />
Die Funktion<span class="function"> motor_set(int16 left, int16 right)</span> setzt die gew&uuml;nschte Sollgeschwindigkeit (F&uuml;hrungsgr&ouml;&szlig;e). Ist diese f&uuml;r
mindestens einen Motor ungleich Null, k&uuml;mmert sich die Funktion<span class="function"> speed_control()</span> um die Einhaltung der
Geschwindigkeit. Wurde eine neue Sollgeschwindigkeit vorgegeben und war au&szlig;erdem die vorherige Geschwindigkeit gleich Null (Anfahren aus dem 
Stand), so sorgen<span class="function"> motor_set()</span> und<span class="function"> speed_control()</span> f&uuml;r ein zun&auml;chst
langsames Anfahren (Hintergrund ist das relativ geringe Drehmoment zu diesem Zeitpunkt, eine genauere Erkl&auml;rung hierzu findet sich 
unter <a href="#pid">Die eigentliche Regelung</a>). Die Istgeschwindigkeit (Regelgr&ouml;&szlig;e) des Bots wird mit den Radencodern gemessen, indem die
seit der letzten (bzw. vor- oder viertletzten, siehe auch <a href="#sensor">Die Sensorauswertung</a>) Encoderflanke vergangene Zeit berechnet wird.<br />
Ist die Regelung aktiv (also das #define<span class="function"> SPEED_CONTROL_AVAILABLE</span> in ct-Bot.h an), werden die Motoren mit einer wesentlich
h&ouml;heren PWM-Frequenz angesteuert (31.200 Hz anstatt 120 Hz), was erstens den Verschlei&szlig; der Motorb&uuml;rsten deutlich reduziert und zweitens
f&uuml;r ein eleganteres Fahrverhalten des Bots sorgt.<br />
Die besten (je kleiner die letzten Fehler waren, desto besser ist das Rating der Werte) PWM-Stellwerte zum Anfahren werden im EEPROM gespeichert, um ein 
m&ouml;glichst sofortiges (und somit f&uuml;r beide R&auml;der gleichzeitiges) Anfahren zu erm&ouml;glichen.</p>
<p>Wer sich nicht f&uuml;r die internen Details der Regelung interessiert, sollte aber zumindest den kompletten Abschnitt <a href="#adjust">
Finden und Einstellen der richtigen Parameter</a> lesen, um die Regelung korrekt einzustellen.</p>

<a name="details"></a><h2>Die Motorregelung im Detail</h2>
<a name="params"></a><h3>Eine &Uuml;bersicht aller Konfigurationsparameter</h3>
<p>Folgende Parameter der Regelung lassen sich in <a href="../include/bot-local.h">include/bot-local.h</a> einstellen:</p>
<ul>
    <li><span class="function"> PID_Kp</span> Der proportionale Anteil des PID-Reglers. Er gibt an, wie stark sich der aktuelle Fehler auf die
    Korrektur der Geschwindigkeit auswirkt. Hier ist in der Regel ein relativ hoher Wert sinnvoll, zugelassen sind Werte von 0 (schaltet den
    P-Anteil komplett aus) bis 127.</li>
    <li><span class="function"> PID_Ki</span> Der integrale Anteil des PID-Reglers. Er gibt an, wie stark sich die Summe der letzten Fehler auf
    die Korrektur der Geschwindigkeit auswirkt. Hier ist in der Regel ein eher kleinerer Wert g&uuml;nstig, zugelassen sind Werte von 0 (schaltet
    den I-Anteil komplett aus) bis 127.</li>
    <li><span class="function"> PID_Kd</span> Der differentielle Anteil des PID-Reglers. Er gibt an, wie stark sich die aktuelle &Auml;nderung der
    Geschwindigkeit (also die Beschleunigung) auf die Korrektur auswirkt. Auch hier ist nur ein kleiner Wert passend, zugelassen sind Werte von 0 
    (schaltet den D-Anteil komplett aus) bis 127.</li>
    <li><span class="function"> PID_Ta</span> Die Abtastzeit. Sie gibt das Verh&auml;ltnis zwischen der Zeitspanne, die seit dem letzten 
    Regleraufruf vergangen ist, und der f&uuml;r die Berechnung erwarteten Zeitspanne an. Normalerweise braucht man hier nichts &auml;ndern und 
    l&auml;sst den Wert auf 1.</li>
    <li><span class="function"> PID_SHIFT</span> Der Divisor der Korrektur. Er gibt an, durch welchen Wert die berechnete &Auml;nderung
    geteilt wird. Anzugeben ist hier der Logarithmus zur Basis 2 (die Division erfolgt durch Bit-Shifting). Damit wird eine m&ouml;glichst
    genaue Einstellung von PID_Kp, PID_Ki und PID_Kd erm&ouml;glicht.</li>
    <li><span class="function"> PID_TIME</span> Das Zeitintervall, nach dem der Regler sp&auml;testens aufgerufen wird in Millisekunden. 
    Wurde nach dieser Zeit keine Encoderflanke registriert, wird von Stillstand ausgegangen. Hier sollte man sich an dem Defaulwert 
    orientieren, Feintuning verbessert evetuell das Verhalten bei sehr kleinen Geschindigkeiten. Zugelassen sind Werte von 0 (das ist aber
    nicht sinnvoll!) bis 655.</li>    
    <li><span class="function"> PID_SPEED_THRESHOLD</span> Die (Soll-)Geschwindigkeit, ab der die Berechnung der Istgeschwindigkeit per
    Interpolation zwischen mehreren Messwerten erfolgt. Sinvoll sind hier BOT_SPEED_SLOW, BOT_SPEED_FOLLOW oder BOT_SPEED_MEDIUM. Detaillierte 
    Informationen finden sich im Erkl&auml;rungstext.</li>     
    <li><span class="function"> PWMMAX</span> Maximaler PWM-Wert. Normalerweise nicht zu ver&auml;ndern.</li>
    <li><span class="function"> PWMMIN</span> Minimaler PWM-Wert. Normalerweise nicht zu ver&auml;ndern.</li>
    <li><span class="function"> PWMSTART_L</span> PWM-Startwert f&uuml;r den linken Motor. Hier sollte man einstellen, ab wann der Motor zu drehen 
    beginnt (unter Last, nicht im Leerlauf).</li>   
    <li><span class="function"> PWMSTART_R</span> PWM-Startwert f&uuml;r den rechten Motor. Hier sollte man einstellen, ab wann der Motor zu drehen 
    beginnt (unter Last, nicht im Leerlauf).</li>   
    <li><span class="function"> PID_START_DELAY</span> Dauer der Anfahrverz&ouml;gerung in Anzahl von Regleraufrufen. Ein kleiner Wert sorgt f&uuml;r
    schnelleres Anfahren, vermindert aber die Stabilit&auml;t der Regelung. Sinnvolle Werte liegen zwischen 10 und 30.</li> 
    <li><span class="function"> ENC_CORRECT_L</span> Korrektur der vom linken Encoder gemessenen Geschwindigkeit in mm/s, falls die Sollgeschwindigkeit
    kleiner als PID_SPEED_THRESHOLD ist. Da das Messverhalten der Radencoder nicht symmetrisch ist, kommt es zu falschen Geschwindigkeitsdaten, 
    wenn die Zeit zwischen zwei direkt aufeinander folgenden Flanken gemessen wird. Um den hier angegebenen Wert wird die errechnete Geschwindigkeit
    korrigiert, falls der Encoderpegel der letzten Flanke HIGH war, anderfalls wird um das Inverse korrigiert. Sinvoll sind Werte zwischen
    -15 und +15.</li>   
    <li><span class="function"> ENC_CORRECT_R</span> Korrektur der vom rechten Encoder gemessenen Geschwindigkeit in mm/s.</li>
</ul>

<a name="pid"></a><h3>Die eigentliche Regelung</h3>
<p>Die Motorregelung basiert auf einem gew&ouml;hnlichen PID-Regler. Dieser ist in der Funktion<span class="function"> 
speed_control(uint8 dev, int16* actVar, uint16* encTime, uint8 i_time, uint8 enc)</span> implementiert. Diese Funktion wird an zwei Stellen
aufgerufen: Erstens aus<span class="function"> bot_encoder_isr()</span> heraus, wenn dort eine neue Flanke eine Radencoders festgestellt wurde
und zweitens aus<span class="function"> bot_sens_isr()</span> heraus, falls in den letzten<span class="function"> PID_TIME</span> ms keine Flanke 
registriert wurde. Letzteres deshalb, damit ein Stillstand des Bots nicht zum Verhungern des Reglers f&uuml;hrt. <br />
Wird durch den Aufruf von<span class="function"> motor_set()</span> eine neue Sollgeschwindigkeit gesetzt, sind zwei F&auml;lle zu unterscheiden: <br />
1.) Die vorherige Geschwindigkeit war gleich Null, es liegt also ein Anlaufen des jeweiligen Rades vor. In diesem Fall ist die Sollgeschwindigkeit 
zun&auml;chst immer<span class="function"> BOT_SPEED_SLOW</span> (oder -<span class="function">BOT_SPEED_SLOW</span>) und wird in den n&auml;chsten
<span class="function"> PID_START_DELAY</span> Regleraufrufen schrittweise auf die gew&uuml;nschte Sollgeschwindigkeit erh&ouml;ht. Hierdurch
wird einerseits eine einheitliche Behandlung des Anlauf-Falls erm&ouml;glicht, was die Codekomplexit&auml;t deutlich reduziert und andererseits
ein (nahezu) ruckfreies Anfahren des Bots erreicht (ist der Verlauf der Geschwindigkeit eine Sinusfunktion, so ist die Beschleunigung (1. Ableitung)
eine Cosinusfunktion und der Ruck (2. Ableitung) wieder eine Sinusfunktion - wir arbeiten auf R&uuml;cksicht der fehlenden FPU der MCU allerdings
nicht mit Sinus, sondern nur mit einer groben N&auml;herung). <br />
2.) Die vorherige Geschwindigkeit war ungleich Null, das Rad ist also bereits in Bewegung. In diesem Fall entfallen die unter 1.) beschriebenen
Spezialf&auml;lle vollst&auml;ndig und der Regler nimmt einfach die neue Sollgeschwindigkeit als F&uuml;hrungsgr&ouml;&szlig;e, den Rest &uuml;bernimmt
der Code automatisch.
</p>

<a name="sensor"></a><h3>Die Sensorauswertung</h3>
<p>Zur Berechnung der aktuellen Geschwindigkeit werden die Radencoder benutzt. Das Messverfahren f&uuml;r die Motorregelung weicht von der allgemeinen
Geschwindigkeitsberechnung des Bots aus zwei Gr&uuml;nden ab: Erstens ist die per<span class="function"> sensor_update()</span> berechnete 
Geschwindigkeit f&uuml;r die Regelung zu ungenau und erfolgt zweitens viel zu selten. Eine schnelle Regelung erfordert das Vorhandensein wirklich
aktueller und zu garantierten Zeiten bereitstehenden Geschwindigkeitsdaten. Berechnet wird die Geschwindigkeit des jeweiligen Rades aus der 
Zeitdifferenz zweier Encoderflanken. Hierbei ist zu beachten, dass zwei direkt aufeinander folgende Flanken unterschiedlicher Natur sind - war die 
Letzte eine steigende Flanke, so muss die N&auml;chste zwangsl&auml;ufig eine Fallende sein und umgekehrt. Die Radencoder registrieren die Flanken
in Abh&auml;ngigkeit der Lichtreflexion der Encoderscheiben, was zur Folge hat, dass bei konstanter Drehgeschwindigkeit des Rades die Zeitspanne 
zwischen einer Steigenden und einer fallenden Flanke nicht gleich der Zeitspanne zwischen einer Fallenden und einer steigenden Flanke sein muss. 
Zwischen Flanken gleicher Art vergeht jedoch bei konstanter Geschwindigkeit immer gleich viel Zeit. Hieraus ergibt sich folgende Konsequenz: 
Entweder zieht man zur Berechnung der Geschwindigkeit jeweils nur Flanken gleicher Art heran, oder man korrigiert die Ungleichheit der Zeitdifferenzen
per Software. Ersteres sorgt f&uuml;r eine deutlich langsamere Geschwindigkeitserfassung, Letzteres f&uuml;r komplexeren Code und mehr 
Konfigurationsparameter. Da bei hohen Geschwindigkeiten sehr oft eine Flanke der Encoder eintrifft, verwendet der Regelungscode das erstgenannte
Verfahren, falls die Sollgeschwindigkeit gr&ouml;&szlig;er als<span class="function"> PID_SPEED_THRESHOLD</span> ist. Au&szlig;erdem wird die Geschwindkeit
aus den letzten vier Encoderflanken berechnet, wenn die Sollgeschwindigkeit gr&ouml;&szlig;er als 2*<span class="function">PID_SPEED_THRESHOLD</span>
ist, um Ungenauigkeiten zu vermeiden, wenn das Zeitintervall zwischen zwei Flanken auf Grund der hohen Geschwindigkeit sehr klein ist. F&uuml;r
langsame Geschwindigkeiten erweist sich das Verfahren allerdings als zu tr&auml;ge, deshalb wird bei Geschwindigkeiten unterhalb von<span class="function"> 
PID_SPEED_THRESHOLD</span> mit jeder Encoderflanke gerechnet und die gemessene Geschwindigkeit um den Betrag<span class="function"> ENC_CORRECT_L</span>
bzw.<span class="function"> ENC_CORRECT_R</span> korrigiert.<br />
Eine (noch) genauere Messung der Geschwindigkeiten ist mit einem kleinen Hardwareumbau zu erreichen: Dreht man die Radencoder um 90 Grad, so
wird das Symmetrieverhalten wesentlich besser und die Zeitspanne zwischen zwei direkt aufeinander folgenden Flanken ist bei konstanter 
Geschwindigkeit immer nahezu gleich. Dadurch kann auch eine Geschwindigkeit von nur 30 mm/s noch ausreichend gut eingeregelt werden (<span class="function"> BOT_SPEED_MIN</span>
in <a href="../include/motor.h">include/motor.h</a> anpassen!). Wer den Umbau der Radencoder nicht scheut, kann dann<span class="function"> ENC_CORRECT_L</span> und<span class="function"> 
ENC_CORRECT_R</span> auf Null setzen, da die Rohdaten der Encoder bereits eine genaue Geschwindigkeitsmessung erm&ouml;glichen.
</p>

<a name="adjust"></a><h3>Finden und Einstellen der richtigen Parameter</h3>
<p>Das Wichtigste f&uuml;r eine gut funktionierende Regelung sind die passenden Parameter Kp, Ki und Kd. Allerdings ist das Berechnen dieser nicht
ganz einfach. Das folgende Einstellverfahren liefert bei vertretbarem Aufwand die besten Ergebnisse: Zuerst stellt man<span class="function"> PID_Kp</span>,<span class="function"> PID_Ki</span>
 und<span class="function"> PID_Kd</span> in <a href="../include/bot-local.h">include/bot-local.h</a> auf <b>0</b> und aktiviert das #define<span class="function"> 
ADJUST_PID_PARAMS</span> in <a href="../ct-Bot.h">ct-Bot.h</a> sowie<span class="function"> DISPLAY_REGELUNG_AVAILABLE</span> in <a href="../ui/available_screens.h">ui/available_screens.h</a>. 
Flasht man nun das erzeugte hex-File auf den Bot, so gibt es einen Display-Screen f&uuml;r die Regelung, der au&szlig;erdem eine spezielle Tastenbelegung
aktiviert. Die erste Displayzeile stellt Istgeschwindigkeit / Sollgeschwindigkeit dar, die Zweite den Betrag des aktuellen Regelfehlers und die Dritte den zurzeit gestellten
PWM-Wert, jeweils f&uuml;r links und rechts. Die letzte Zeile gibt die derzeit einstellten PID-Parameter aus. Nun sollte der Bot mit<span class="function"> BOT_SPEED_SLOW</span>, 
also 50 mm/s, auf der Stelle drehen. Das erreicht man am Einfachsten mit der Pfeiltaste links oder rechts auf der Fernbedienung. Anschlie&szlig;end erh&ouml;ht man schrittweise
Kp mit der Taste 1, bis sich der Bot noch mit ann&auml;hernd konstanter Geschwindigkeit auf der Stelle dreht. Wird Kp zu gro&szlig;, beginnt der Regler zu schwingen und man stellt Kp
mit der Taste 4 wieder etwas zur&uuml;ck, bis das Schwingen aufh&ouml;rt. Jetzt kann man Ki mit der Taste 2 vergr&ouml;&szlig;ern, der Wert sollte aber deutlich kleiner als Kp bleiben.
Mit der Taste 5 kann man Ki wieder verringern. Mit erh&ouml;htem Ki kann man auch Kp noch ein wenig vergr&ouml;&szlig;ern, da der Regler nun stabiler geworden sein sollte. Es empfiehlt sich,
w&auml;hrend des Einstellens den Bot ab und zu anzuhalten und das Drehen oder Fahren aus dem Stand von Neuem beginnen zu lassen, um &uuml;berpr&uuml;fen zu k&ouml;nnen, ob der Regler 
auch schnell genug die gew&uuml;nschte Sollgeschwindigkeit einregelt. Hier hilft eventuell der D-Anteil des PID-Reglers, den man mit dem Parameter<span class="function"> PID_Kd</span> aktiviert. 
Taste 3 erh&ouml;ht diesen, Taste 6 verringert ihn. Vorsicht, ist Kd zu gro&szlig;, leidet die Stabilit&auml;t der Regelung darunter.<br />
Hat man die Parameter gefunden, die zum besten Ergebnis f&uuml;hren, so tr&auml;gt man diese in <a href="../include/bot-local.h">include/bot-local.h</a> ein und schaltet das #define
<span class="function"> ADJUST_PID_PARAMS</span> in <a href="../ct-Bot.h">ct-Bot.h</a> wieder aus, damit ein Teil der PID-Regler-Gleichung bereits zur Compilezeit berechnet und der
Mikrocontroller somit entlastet werden kann. </p>
<p>Allgemein gilt f&uuml;r die Parameter: Je gr&ouml;&szlig;er sie sind, desto <i>schneller</i> ist die Regelung, je kleiner sie sind, desto <i>stabiler</i> ist die Regelung. Sollte der 
Wertebereich von 0 bis 127 nicht ausreichen, so kommt der Parameter<span class="function"> PID_SHIFT</span> ins Spiel. Erh&ouml;ht man ihn um eins, so ist das Gleichbedeutend mit der 
Halbierung von Kp, Ki und Kd. Verringert man ihn um eins, so entspricht das der Verdoppelung von Kp, Ki und Kd. F&uuml;r die beste Einstellgenauigkeit w&auml;hlt man also<span 
class="function"> PID_SHIFT</span> so, dass<span class="function"> PID_Kp</span> (sollte den gr&ouml;&szlig;ten Wert unter den Parametern haben) zwischen 64 und 127 liegt.</p>
<p>Da das Einstellen der Parameter etwas knifflig ist, w&auml;re es sch&ouml;n und hilfreich, die eingestellten Parameter ebenso wie weitere Erfahrungen mit der Regelung zu sammeln.
Dazu gibt es im <a href="http://www.heise.de/ct/foren/go.shtml?list=1&amp;forum_id=89813">Forum</a> einen Thread. Wenn dann z.B. auf 90% aller Bots die Parameter x, y, z die besten Ergebnisse
liefern, werden dies die Default-Werte im SVN.
</p>

<a name="log"></a><h3>Die Logging-Funktion</h3>
<p>TODO!
</p>

<br /><br />
<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Transitional" height="31" width="88" /></a></p>  
</body>
</html>