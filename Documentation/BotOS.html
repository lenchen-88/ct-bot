<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="description" content="&Uuml;bersicht des Mini-OS des c't-Bots" />
<meta name="author" content="Timo Sandmann" />
<meta name="keywords" content="c't-Bot,BotOS" />
<meta name="date" content="2007-10-14" />
<title>c't-Bot - BotOS</title>
<link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
<h1>Dokumentation zum c't-Bot-Minibetriebssystem</h1>
<div style="text-align:center;color:red">Dokumentation nicht mehr aktuell!</div>
<br />

<a class="menu" href="#allgemeines">Allgemeines</a><br />
<a class="menu" href="#interna">Interne Details</a><br />
<a class="menu" href="#hinweise">Weitere Hinewise</a><br />

<a name="allgemeines"></a><h2>Allgemeines</h2>
<p>Unser kleines BotOS kann mehrere Aufgaben "parallel" abarbeiten.<br />
Die ausf&uuml;hrenden Einheiten hei&szlig;en<span class="function"> Thread</span> (denn sie leben ja alle im selben
Adressraum).<br />
Es gibt nur einen Scheduler, daher wird nicht weiter zwischen Kernel-Level-Threads 
und User-Level-Threads unterschieden.<br />
Ein Thread besteht aus einem<span class="function"> Stack</span>, einem Timestamp<span class="function"> fr&uuml;hester Zeitpunkt 
der n&auml;chsten Ausf&uuml;hrung</span> und der<span class="function"> letzten Laufzeit</span>, die zusammen den<span class="function"> Thread 
Control Block (TCB)</span> bilden, und indirekt einer<span class="function"> Priorit&auml;t</span>.<br /> 
Der zuerst angelegte Thread hat die h&ouml;chste Priorit&auml;t, der n&auml;chste die 
Zweith&ouml;chste usw. <br />
Es kann somit keine Priorit&auml;t doppelt vergeben werden.<br />
Threads k&ouml;nnen zwar zur Laufzeit erzeugt, aber nicht wieder beendet werden.<br />
Um einen neuen Thread zu erzeugen (&uuml;blicherweise in einer Init-Funktion), ruft man die
Funktion<span class="function"> os_create_thread(uint8_t * pStack, void * pIp)</span> auf und
&uuml;bergibt ihr einen Zeiger auf den Stack des neuen Threads (Vorsicht, der Zeiger muss
auf das letzte Byte des Stacks zeigen, weil der Stack auf der AVR-Architektur von hohen zu niedrigen
Adressen w&auml;chst) sowie einen Zeiger auf die Main-Funktion des Threads. Im Erfolgsfall
bekommt man einen Zeiger auf den TCB des neuen Threads zur&uuml;ck (den man braucht, um den Thread
identifizieren zu k&ouml;nnen), im Fehlerfall ist das Resultat NULL. <br />
Um den ersten Thread im System anzulegen (der ja bereits l&auml;uft und hier Main-Thread genannt wird, weil er die 
h&ouml;chste Priorit&auml;t hat), &uuml;bergibt mal als Stackpointer <i>(uint8_t *)SP</i> und als Instruction-Pointer <i>NULL</i>
 (der erste Threadswitch sichert den korrekten IP dann auf dem Stack).<br />
Die Anzahl der m&ouml;glichen Threads ist durch<span class="function"> OS_MAX_THREADS</span> in os_thread.h festgelegt.
Hier sollte man nicht mehr als n&ouml;tig einstellen, um RAM zu sparen (es gibt ein statisches
Array f&uuml;r alle TCBs der Gr&ouml;&szlig;e OS_MAX_THREADS). </p> 
 
<p>Als Scheduling-Verfahren wird FPP (Fixed-Priority-Preemptive) verwendet, um die Implementierung m&ouml;glichst klein
und effizient zu halten. Es sei angemerkt, dass dieses Verfahren nur unter bestimmten Umst&auml;nden optimal ist,
die Einhaltung von Zeitschranken h&auml;ngt vor allem von der gew&auml;hlten Priorit&auml;tenverteilung ab. F&uuml;r unsere
Zwecke sollte das aber ausreichend sein.</p>

<p>Ein Thread kann eine beliebige Anzahl an ms schlafen und somit die Kontrolle
an einen anderen Thread abgeben, indem er<span class="function"> os_thread_sleep(ms)</span> aufruft.<br /> 
Ruft ein Thread<span class="function"> os_thread_yield()</span> auf, schl&auml;ft er (mindestens) f&uuml;r die Dauer 
einer Zeitscheibe minus seiner bisherigen Laufzeit. Man muss<span class="function"> yield()</span> also periodisch 
aufrufen, damit das Ganze Sinn macht. Die Berechnung ist nur dann korrekt, wenn
der Thread, der yield() benutzt, nicht l&auml;nger als 44 ms blockiert wird, weil hier
zum Teil in 8 Bit gerechnet wird (Effizienzvorteil). Der Gedanke dahinter ist, dass
ein Thread, der nur selten l&auml;uft, keine so exakte Zeitangabe der n&auml;chsten Ausf&uuml;hrung
ben&ouml;tigt und deshalb einfach<span class="function"> sleep()</span> benutzen kann (s.o.).</p>
 
<p>Eine Zeitscheibe dauert derzeit 10 ms, einstellen l&auml;sst sich das in os_scheduler.h
mit dem #define<span class="function"> OS_TIME_SLICE</span> in ms-Schritten.<br />
Die Scheduling-Aufl&ouml;sung betr&auml;gt ca. 1 ms.</p>
 
<p>Wacht ein h&ouml;her prior&auml;r Thread wieder auf (= Schlafzeit zuende), wird dem 
Aktuellen die Ausf&uuml;hrung entzogen.</p>
 
<p>Identifiziert werden Threads durch die (eindeutige) Adresse ihres<span class="function"> TCBs</span>. 
Es gibt also keine Thread-ID.</p> 
 

<a name="interna"></a><h2>Interne Details</h2>
<p>Dieser Abschnitt ist nur dann wichtig, wenn man etwas am Scheduler und / oder an der
Timer-ISR ver&auml;ndern oder erweitern m&ouml;chte.</p>

<p><span class="function">os_switch_thread()</span> darf ausschlie&szlig;lich vom Scheduler aus aufgerufen werden!<br />
<span class="function">os_switch_helper()</span> kann nur von<span class="function"> os_switch_thread()</span> verwendet werden!</p>
 
<p>Man kann den Teil der Timer-ISR, der den Scheduler aufruft und den Scheduler selbst
als eine Art<span class="function"> Kernel</span> ansehen. Es gibt jedoch (aus Effizienzgr&uuml;nden) <b>keinen</b> Kernel-Stack, 
weder pro Thread, noch einen Allgemeinen. Das hat zur Folge, dass ein vom Scheduler 
angesto&szlig;ener Threadwechsel <b>sofort</b> ausgef&uuml;hrt wird. <br />
Falls also ein Threadwechsel von <i>A</i> nach <i>B</i> ansteht, wird die Scheduler-Funktion (und die 
Timer-ISR ebenfalls) von <i>Thread A</i> aufgerufen und von <i>Thread B</i>(!) wieder verlassen. Erfolgt 
sp&auml;ter umgekehrt ein Wechsel von <i>B</i> zur&uuml;ck nach <i>A</i>, wird der beim ersten Wechsel 
"aufgeschobene" R&uuml;cksprung vom Scheduler zur&uuml;ck nach <i>Thread A</i> zu diesem Zeitpunkt 
ausgef&uuml;hrt / "nachgeholt". <br />
Es muss also gew&auml;hrleistet sein, dass der Code (im Scheduler) <b>nach</b> dem Threadwechsel f&uuml;r 
<b>alle</b> Threads identisch ist.<br />
Da es zwei unterschiedliche Gr&uuml;nde f&uuml;r einen Threadwechsel geben kann (<i>hart</i> per 
Timer-ISR, weil der aktuelle Thread nicht mehr weiterlaufen darf, und <i>kooperativ</i> vom 
Thread selbst gew&uuml;nscht, weil dieser<span class="function"> sleep()</span> oder<span class="function"> yield()</span> aufgerufen hat), erfolgt der 
R&uuml;cksprung aus dem Scheduler nicht zwangsweise an die Codestelle, die (direkt) vor dem
Scheduler-Aufruf ausgef&uuml;hrt wurde. Daher darf <b>nach</b> dem Scheduler-Aufruf in der Timer-ISR
kein Code mehr folgen, der bei jedem Timer-Tick ausgef&uuml;hrt werden soll. Solcher Code
muss unbedingt <b>vor</b> dem Scheduler-Aufruf stehen.</p>

<a name="hinweise"></a><h2>Weitere Hinweise</h2>
<p>Aufpassen muss man bei m&ouml;glichen Ressourcen-Konflikten: Z.B. Darf nicht w&auml;hrend eines
Display- oder ENA-Zugriffs auf einen anderen Thread umgeschaltet werden, der dann evtl.
auch auf das Display oder eine ENA-Leitung zugreifen m&ouml;chte, denn die Schieberegister-Operationen
sind nicht atomar. &Auml;hnlich verh&auml;lt es sich mit LOG- oder UART-Zugriffen. 
F&uuml;r MMC und Maussensor ist ein entsprechender Schutz (mit<span class="function"> os_enterCS()</span> und<span class="function"> os_exitCS()</span>) 
bereits im MMC- und ENA-Code vorhanden, andere Ressourcen sind derzeit nicht gesch&uuml;tzt, 
da es neben dem Main-Thread bisher nur einen weiteren zum Map-Update gibt (und das Map-Update
 nicht auf das Display oder andere ENA-Leitungen zugreift). <br />
M&ouml;chte man weitere Threads f&uuml;r andere Zwecke hinzuf&uuml;gen, muss man w&auml;hrend des
Zugriffs auf gemeinsam genutzte Ressourcen entweder das Scheduling tempor&auml;r deaktivieren
(mit<span class="function"> os_enterCS()</span> und<span class="function"> os_exitCS()</span> entweder im Thread-Code oder im Display- / ENA-Code), 
oder die jeweiligen Ressourcen z.B. per Mutex sperren.<br />
Bei letzterem m&uuml;sste man aber aufpassen, keine sich &uuml;berkreuzenden Zugriffe zu erzeugen,
um Dead- oder Livelocks zu vermeiden. <br />
Um diesen Problemen aus dem Weg zu gehen, ist derzeit nur der MMC-Zugriff in einen extra 
Thread ausgelagert. </p>

<p>Ebenfalls will die Stack-Gr&ouml;&szlig;e eines Threads sorgf&auml;ltig &uuml;berlegt sein, da auf dem Stack
beim Threadwechsel der komplette Kontext (die 32 GP-Register, das Statusregister und der 
Instruction-Pointer) gesichert wird. Nicht-statische, lokale Variablen legt der Compiler
ebenfalls auf dem Stack ab, sobald sie nicht mehr in Registern untergebracht werden 
k&ouml;nnen oder eine Adresseberechnung gebraucht wird (z.B. bei Arrays). Man sollte daher
(gr&ouml;&szlig;ere) lokale Arrays als statisch deklarieren. <br />
Au&szlig;erdem sollten viele verschachtelte Funktionsaufrufe m&ouml;glichst vermieden werden, da
f&uuml;r jeden Funktionsaufruf die R&uuml;cksprungadresse sowie evtl. gesicherte Register ebenfalls
auf dem Stack Platz finden m&uuml;ssen.</p>

<p>F&uuml;r den PC-Code gibt es bisher keine Thread-Implementierung, d.h. man muss mindestens die
while-Schleife im Thread-Code per #ifdef auf den MCU-Fall beschr&auml;nken und den 
Threadwechsel im PC-Fall durch den Funktionsaufruf der Thread-Main-Funktion ersetzen.</p>


<br /><br />
<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Transitional" height="31" width="88" /></a></p>  
</body>
</html>